#' @title Calibrate weights
#'
#' @description
#' Calibrate weights for bootstrap replicates by using iterative proportional updating to match population totals on various household and personal levels.
#'
#' @details
#' \code{recalib} takes survey data (\code{dat}) containing the bootstrap replicates generated by \code{\link{draw.bootstrap}} and calibrates weights for each bootstrap
#' replication according to population totals for person- or household-specific variables. \cr
#' \code{dat} must be household data where household members correspond to multiple rows with the same household identifier. The data should at least containt the following columns:
#' \itemize{
#'   \item Column indicating the sample year;
#'   \item Column indicating the household ID;
#'   \item Column containing the household sample weights;
#'   \item Columns which contain the bootstrap replicates (see output of \code{\link{draw.bootstrap}});
#'   \item Columns indicating person- or household-specific variables for which sample weight should be adjusted.
#' }
#' For each year and each variable in \code{conP.var} and/or \code{conH.var} contingency tables are estimated to get margin totals on personal- and/or household-specific variables in the population.\cr
#' Afterwards the bootstrap replicates are multiplied with the original sample weight and the resulting product ist then adjusted using \code{\link[simpPop]{ipu2}} to match the previously calcualted contingency tables.
#' In this process the columns of the bootstrap replicates are overwritten by the calibrated weights.\cr
#'
#'
#' @param dat either data.frame or data.table containing the sample survey for various years.
#' @param hid character specifying the name of the column in \code{dat} containing the household ID.
#' @param weights character specifying the name of the column in \code{dat} containing the sample weights.
#' @param b.rep character specifying the names of the columns in \code{dat} containing bootstrap weights which should be recalibratet
#' @param year character specifying the name of the column in \code{dat} containing the sample years.
#' @param country character specifying the name of the column in \code{dat} containing the country name. Is only used if \code{dat} contains data from multiple countries.
#' In this case the calibration procedure will be applied on each country seperately. If \code{country=NULL} the household identifier must be unique for each household.
#' @param conP.var character vector containig person-specific variables to which weights should be calibrated. for which contingency tables for the population tables are calculatet per \code{year} and
#' @param conH.var character vector containig household-specific variables to which weights should be calibrated.
#' @param ... additional arguments passed on to function \code{\link[simpPop]{ipu2}} from the \code{simPop} package.
#'
#'
#' @return Returns a data.table containing the survey data as well as the calibrated weights for the bootstrap replicates, which are labeled like the bootstrap replicates.
#'
#' @seealso \code{\link[simpPop]{ipu2}} for more information on iterative proportional fitting.
#'
#' @author Johannes Gussenbauer, Alexander Kowarik, Statistics Austria
#'
#' @examples
#' # read in data (need to be changed)
#' library(data.table)
#' dat <- data.table(read_sas("O:/B/3-AP/Analyse/sonstiges/
#'                             bundesländerschätzungen 2008-2018/daten/bldaten0816.sas7bdat"))
#' # draw bootstrap replicates
#' dat <- draw.bootstrap(dat,REP=20,hid="hid",weights="hgew",
#'                      strata="bundesld",year="jahr",totals=NULL,boot.names=NULL)
#'
#' # or load data with replicates if they have already been saved
#' # load("dat_replicates.RData")
#'
#' # calibrate weight for bootstrap replicates
#' # use sex for person-specific and hsize for household-specific marginals
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("sex"),conH.var=c("hsize"))
#'
#'
#' # do the same but expand person- and household specific variables
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("sex","ageX"),conH.var=c("bundesld","hsize"))
#'
#'
#' # for many variables (household- or person-specific)
#' # use increase maxIter to get convergence
#' dat_calib <- recalib(dat=copy(dat),hid="hid",weights="hgew",b.weights=paste0("w",1:20),
#'                      year="jahr",conP.var=c("ksex","age","bildung","kausl","al","erw","pension"),
#'                      conH.var=c("bundesld","hsize","recht"),maxIter=100)
#'
#' # save calibrated bootstrap weights as .RData
#' save(dat_calib,file="dat_calibweight.RData")
#' # or .csv-file
#' write.csv2(dat_calib,file="dat_calibweight.csv",row.names=FALSE)
#'
#' @export recalib
#' @import simPop data.table

recalib <- function(dat,hid="hid",weights="hgew",b.rep=paste0("w",1:1000),year="jahr",country=NULL,conP.var=c("ksex","kausl","al","erw","pension"),
										conH.var=c("bundesld","hsize","recht"),...,hidf_factor=TRUE){
  ##########################################################
  # INPUT CHECKING
  if(class(dat)[1]=="data.frame"){
    dat <- as.data.table(dat)
  }else if(class(dat)[1]!="data.table"){
    stop("dat must be a data.frame or data.table")
  }

  c.names <- colnames(dat)

  # check hid
  if(length(hid)!=1){
    stop("hid must have length 1")
  }
  if(!hid%in%c.names){
    stop(paste0(hid," is not a column in dat"))
  }

  # check weights
  if(length(weights)!=1){
    stop("weights must have length 1")
  }
  if(!weights%in%c.names){
    stop(paste0(weights," is not a column in dat"))
  }
  if(!is.numeric(dt.eval("dat[,",weights,"]"))){
    stop(paste0(weights," must be a numeric column"))
  }

  # check b.rep
  if(!all(b.rep%in%c.names)){
    stop("Not all elements in b.rep are column names in dat")
  }
  if(any(!grepl("^[[:alpha:]]",b.rep))){
    stop("Column names of bootstrap replicates must start with alphabetic character")
  }
  if(any(!unlist(lapply(dat[,mget(b.rep)],is.numeric)))){
    stop("Column containing bootstrap replicates must be numeric")
  }

  # check conP.var
  if(!all(conP.var%in%c.names)){
    stop("Not all elements in conP.var are column names in dat")
  }

  # check conH.var
  if(!all(conH.var%in%c.names)){
    stop("Not all elements in conH.var are column names in dat")
  }

  # check year
  if(length(year)!=1){
    stop(paste0(year," must have length 1"))
  }
  if(!year%in%c.names){
    stop(paste0(year," is not a column in dat"))
  }

  # check country
  if(!is.null(country)){
    if(length(country)!=1){
      stop(paste0(country," must have length 1"))
    }
    if(!country%in%c.names){
      stop(paste0(country," is not a column in dat"))
    }
  }


  ##########################################################

	# define default values for ipu2
  ellipsis <- list(...)
  ellipsis[["verbose"]] <- getEllipsis("verbose",TRUE,ellipsis)
  ellipsis[["epsP"]] <- getEllipsis("epsP",1e-2,ellipsis)
  ellipsis[["epsH"]] <- getEllipsis("epsH",5e-2,ellipsis)
  ellipsis[["bound"]] <- getEllipsis("bound",4,ellipsis)
  ellipsis[["maxIter"]] <- getEllipsis("maxIter",50,ellipsis)
  ellipsis[["meanHH"]] <- getEllipsis("meanHH",TRUE,ellipsis)
  ellipsis[["check_hh_vars"]] <- getEllipsis("check_hh_vars",FALSE,ellipsis)
  ellipsis[["conversion_messages"]] <- getEllipsis("conversion_messages",FALSE,ellipsis)

  eval(parse(text=paste(names(ellipsis),unlist(lapply(ellipsis,as.character)),sep="<-")))

  # combine year and county
  if(!is.null(country)){
    country_lev <- dt.eval("dat[,unique(",country,")]")
  }else{
    country_lev <- NULL
  }


  # recode factors to numeric or character
  # is needed for ipu2 call
  # options(warn=-1) # turn off warnings
  # con.var <- c(conP.var,conH.var)
  # con.var.recode <- rep(FALSE,length(con.var))
  # for(i in 1:length(con.var)){
  #   if(dt.eval("dat[,class(",con.var[i],")]")=="factor"){
  #     isf.i <- paste0(con.var[i],"isfactor")
  #     dt.eval("dat[,",isf.i,":=",con.var[i],"]")
  #     dt.eval("dat[,",con.var[i],":=as.numeric(levels(",con.var[i],"))[",con.var[i],"]]")
  #
  #     if(any(dt.eval("dat[,is.na(",con.var[i],")]"))){
  #       dt.eval("dat[,",con.var[i],":=levels(",isf.i,")[",isf.i,"]]")
  #     }
  #
  #     con.var.recode[i] <- TRUE
  #   }
  # }
  # con.var <- con.var[con.var.recode]
  # # turn warnings on again
  # options(warn=0)

  # recode household and person variables to factor
  # improves runtime for ipu2
  #
  vars <- c(year,country,conP.var,conH.var)
  vars.class <- unlist(lapply(dat[,mget(vars)],class))
  # convert to factor
  for(i in 1:length(vars)){
    if(vars.class[[vars[i]]]!="factor"){
      dt.eval("dat[,",vars[i],":=as.factor(",vars[i],")]")
    }
  }

	# calculate contingency tables
	if(!is.null(conP.var)){
	  if(!is.null(country)){
	    conP <- lapply(country_lev,function(co){
	      dat_co <- dt.eval("dat[",country,"=='",co,"']")
	      lapply(conP.var,function(z){
	        form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
	        dt.eval("xtabs(",form.z,",data=dat_co[,sum(",weights,"),by=list(",year,",",z,")])")
	      })
	    })
	    names(conP) <- country_lev
	  }else{
	    conP <- lapply(conP.var,function(z){
	      form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
	      dt.eval("xtabs(",form.z,",data=dat[,sum(",weights,"),by=list(",year,",",z,")])")
	    })
	  }
	}else{
		conP <- NULL
	}
	if(!is.null(conH.var)){
    if(!is.null(country)){
      dt.eval("dat[,onePerson:=c(1L,rep(0,.N-1)),by=list(",hid,",",year,",",country,")]")
      conH <- lapply(country_lev,function(co){
        dat_co <- dt.eval("dat[",country,"=='",co,"']")
        conH <- lapply(conH.var,function(z){
          form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
          dt.eval("xtabs(",form.z,",data=dat_co[,sum(onePerson*",weights,"),by=list(",year,",",z,")])")
        })
      })
      names(conH) <- country_lev
    }else{
      dt.eval("dat[,onePerson:=c(1L,rep(0,.N-1)),by=list(",hid,",",year,")]")
      conH <- lapply(conH.var,function(z){
        form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
        dt.eval("xtabs(",form.z,",data=dat[,sum(onePerson*",weights,"),by=list(",year,",",z,")])")
      })
    }

	}else{
		conH <- NULL
	}


	# define new Index
	new_id <- paste(c(hid,year,country),collapse=",")
	if(hidf_factor){
	  dt.eval("dat[,hidf:=factor(paste0(",new_id,"))]")
	}else{
	  dt.eval("dat[,hidf:=paste0(",new_id,")]")
	}

	# calibrate weights to conP and conH
	select.var <- c("hidf",weights,year,country,conP.var,conH.var)
  if(!is.null(country)){
	  dat_country <- list()
	  for(co in country_lev){
	    dat_c <- dt.eval("dat[",country,"=='",co,"']")
	    for(g in b.rep){
	      set(dat_c,j=g,value=dt.eval("dat_c[,",g,"*",weights,"]"))
	      set(dat_c,j=g,value=ipu2(dat=copy(dat_c[,mget(c(g,select.var))]),conP=conP[[co]],
	                             conH=conH[[co]],verbose=verbose,epsP=epsP,epsH=epsH,
	                             w=g,bound=bound,maxIter=maxIter,meanHH=,meanHH,hid="hidf",
	                             check_hh_vars = check_hh_vars,conversion_messages = conversion_messages)[,calibWeight])
	    }
	    dat_country <- c(dat_country,list(dat_c))
	  }
	  dat <- rbindlist(dat_country)
	  rm(dat_country)
	}else{
	  for(g in b.rep){
	    set(dat,j=g,value=dt.eval("dat[,",g,"*",weights,"]"))
	    set(dat,j=g,value=ipu2(dat=copy(dat[,mget(c(g,select.var))]),conP=conP,
	                           conH=conH,verbose=verbose,epsP=epsP,epsH=epsH,
	                           w=g,bound=bound,maxIter=maxIter,meanHH=,meanHH,hid="hidf",
	                           check_hh_vars = check_hh_vars,conversion_messages = conversion_messages)[,calibWeight])
	  }
	}

	dat[,hidf:=NULL]

	# replace the recoded variables by the original ones
  # if(length(con.var)>0){
  #   for(i in 1:length(con.var)){
  #     isf.i <- paste0(con.var[i],"isfactor")
  #     dt.eval("dat[,",con.var[i],":=",isf.i ,"]")
  #     dt.eval("dat[,",isf.i ,":=NULL]")
  #   }
  # }
	# recode vars back to either integer of character
	for(i in 1:length(vars.class)){
	  if(vars.class[i]%in%c("integer","numeric")){
	    dt.eval("dat[,",vars[i],":=as.numeric(as.character(",vars[i],"))]")
	  }else if(vars.class[i]=="character"){
	    dt.eval("dat[,",vars[i],":=as.character(",vars[i],")]")
	  }
	}


	return(dat)
}


