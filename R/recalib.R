#' @title Calibrate weights
#'
#' @description
#' Calibrate weights for bootstrap replicates by using iterative proportional updating to match population totals on various household and personal levels.
#'
#' @usage recalib(dat,hid="DB030",weights="RB050",b.rep=paste0("w",1:1000),year="RB010",
#'                country=NULL,conP.var=c("RB090"),conH.var=c("DB040","DB100"),...)
#'
#' @details
#' \code{recalib} takes survey data (\code{dat}) containing the bootstrap replicates generated by \code{\link{draw.bootstrap}} and calibrates weights for each bootstrap
#' replication according to population totals for person- or household-specific variables. \cr
#' \code{dat} must be household data where household members correspond to multiple rows with the same household identifier. The data should at least containt the following columns:
#' \itemize{
#'   \item Column indicating the sample year;
#'   \item Column indicating the household ID;
#'   \item Column containing the household sample weights;
#'   \item Columns which contain the bootstrap replicates (see output of \code{\link{draw.bootstrap}});
#'   \item Columns indicating person- or household-specific variables for which sample weight should be adjusted.
#' }
#' For each year and each variable in \code{conP.var} and/or \code{conH.var} contingency tables are estimated to get margin totals on personal- and/or household-specific variables in the population.\cr
#' Afterwards the bootstrap replicates are multiplied with the original sample weight and the resulting product ist then adjusted using \code{\link[simpPop]{ipu2}} to match the previously calcualted contingency tables.
#' In this process the columns of the bootstrap replicates are overwritten by the calibrated weights.\cr
#'
#'
#' @param dat either data.frame or data.table containing the sample survey for various years.
#' @param hid character specifying the name of the column in \code{dat} containing the household ID.
#' @param weights character specifying the name of the column in \code{dat} containing the sample weights.
#' @param b.rep character specifying the names of the columns in \code{dat} containing bootstrap weights which should be recalibratet
#' @param year character specifying the name of the column in \code{dat} containing the sample years.
#' @param country character specifying the name of the column in \code{dat} containing the country name. Is only used if \code{dat} contains data from multiple countries.
#' In this case the calibration procedure will be applied on each country seperately. If \code{country=NULL} the household identifier must be unique for each household.
#' @param conP.var character vector containig person-specific variables to which weights should be calibrated. for which contingency tables for the population tables are calculatet per \code{year} and
#' @param conH.var character vector containig household-specific variables to which weights should be calibrated.
#' @param ... additional arguments passed on to function \code{\link[simpPop]{ipu2}} from the \code{simPop} package.
#'
#'
#' @return Returns a data.table containing the survey data as well as the calibrated weights for the bootstrap replicates, which are labeled like the bootstrap replicates.
#' If calibration of a bootstrap replicate does not converge the bootsrap weight is not returned and numeration of the returned bootstrap weights is reduced by one.
#'
#'
#' @seealso \code{\link[simpPop]{ipu2}} for more information on iterative proportional fitting.
#'
#' @author Johannes Gussenbauer, Alexander Kowarik, Statistics Austria
#'
#' @examples
#' library(data.table)
#' # run on UDB SILC-data
#' # example for SILC-data for Austria
#' # dat_at <- fread("path//to//austrian//data.csv")
#'
#' dat_boot <- draw.bootstrap(dat=dat_at,REP=250,hid="DB030",weights="RB050",strata="DB040",
#'                            year="RB010",split=TRUE,pid="RB030")
#'
#'
#' # calibrate weight for bootstrap replicates
#' dat_boot_calib <- recalib(dat=copy(dat_boot),hid="DB030",weights="RB050",
#'                           year="RB010",b.rep=paste0("w",1:250),conP.var=c("RB090"),conH.var = c("DB040"))
#'
#'
#' # calibrate on other variable
#' dat_boot_calib <- recalib(dat=copy(dat_boot),hid="DB030",weights="RB050",
#'                           year="RB010",b.rep=paste0("w",1:250),conP.var=c("RB090"),conH.var = c("HX080","DB100"))
#'
#'
#' # save calibrated bootstrap weights as .RData
#' save(dat_boot_calib,file="dat_calibweight.RData")
#' # or .csv-file
#' write.csv2(dat_boot_calib,file="dat_calibweight.csv",row.names=FALSE)
#'
#' @export recalib
#' @import simPop data.table

recalib <- function(dat,hid="DB030",weights="RB050",b.rep=paste0("w",1:1000),year="jahr",country=NULL,conP.var=c("RB090"),
										conH.var=c("DB040","DB100"),...){
  ##########################################################
  # INPUT CHECKING
  if(class(dat)[1]=="data.frame"){
    dat <- as.data.table(dat)
  }else if(class(dat)[1]!="data.table"){
    stop("dat must be a data.frame or data.table")
  }

  c.names <- colnames(dat)

  # check hid
  if(length(hid)!=1){
    stop("hid must have length 1")
  }
  if(!hid%in%c.names){
    stop(paste0(hid," is not a column in dat"))
  }

  # check weights
  if(length(weights)!=1){
    stop("weights must have length 1")
  }
  if(!weights%in%c.names){
    stop(paste0(weights," is not a column in dat"))
  }
  if(!is.numeric(dt.eval("dat[,",weights,"]"))){
    stop(paste0(weights," must be a numeric column"))
  }

  # check b.rep
  if(!all(b.rep%in%c.names)){
    stop("Not all elements in b.rep are column names in dat")
  }
  if(any(!grepl("^[[:alpha:]]",b.rep))){
    stop("Column names of bootstrap replicates must start with alphabetic character")
  }
  if(any(!unlist(lapply(dat[,mget(b.rep)],is.numeric)))){
    stop("Column containing bootstrap replicates must be numeric")
  }

  # check conP.var
  if(!all(conP.var%in%c.names)){
    stop("Not all elements in conP.var are column names in dat")
  }

  # check conH.var
  if(!all(conH.var%in%c.names)){
    stop("Not all elements in conH.var are column names in dat")
  }

  # check year
  if(length(year)!=1){
    stop(paste0(year," must have length 1"))
  }
  if(!year%in%c.names){
    stop(paste0(year," is not a column in dat"))
  }

  # check country
  if(!is.null(country)){
    if(length(country)!=1){
      stop(paste0(country," must have length 1"))
    }
    if(!country%in%c.names){
      stop(paste0(country," is not a column in dat"))
    }
  }


  ##########################################################

	# define default values for ipu2
  ellipsis <- list(...)
  ellipsis[["verbose"]] <- getEllipsis("verbose",TRUE,ellipsis)
  ellipsis[["epsP"]] <- getEllipsis("epsP",1e-2,ellipsis)
  ellipsis[["epsH"]] <- getEllipsis("epsH",5e-2,ellipsis)
  ellipsis[["bound"]] <- getEllipsis("bound",4,ellipsis)
  ellipsis[["maxIter"]] <- getEllipsis("maxIter",100,ellipsis)
  ellipsis[["meanHH"]] <- getEllipsis("meanHH",TRUE,ellipsis)
  ellipsis[["check_hh_vars"]] <- getEllipsis("check_hh_vars",FALSE,ellipsis)
  ellipsis[["conversion_messages"]] <- getEllipsis("conversion_messages",FALSE,ellipsis)

  eval(parse(text=paste(names(ellipsis),unlist(lapply(ellipsis,as.character)),sep="<-")))

  # combine year and county
  if(!is.null(country)){
    country_lev <- dt.eval("dat[,unique(",country,")]")
  }else{
    country_lev <- NULL
  }


  # recode factors to numeric or character
  # is needed for ipu2 call
  # if(!ipu2new){
  #   options(warn=-1) # turn off warnings
  #   con.var <- c(conP.var,conH.var)
  #   con.var.recode <- rep(FALSE,length(con.var))
  #   for(i in 1:length(con.var)){
  #     if(dt.eval("dat[,class(",con.var[i],")]")=="factor"){
  #       isf.i <- paste0(con.var[i],"isfactor")
  #       dt.eval("dat[,",isf.i,":=",con.var[i],"]")
  #       dt.eval("dat[,",con.var[i],":=as.numeric(levels(",con.var[i],"))[",con.var[i],"]]")
  #
  #       if(any(dt.eval("dat[,is.na(",con.var[i],")]"))){
  #         dt.eval("dat[,",con.var[i],":=levels(",isf.i,")[",isf.i,"]]")
  #       }
  #
  #       con.var.recode[i] <- TRUE
  #     }
  #   }
  #   con.var <- con.var[con.var.recode]
  #   # turn warnings on again
  #   options(warn=0)
  #   hidf_factor <- FALSE
  # }

  # recode household and person variables to factor
  # improves runtime for ipu2
  #

  vars <- c(year,country,conP.var,conH.var)
  vars.class <- unlist(lapply(dat[,mget(vars)],function(z){
    z.class <- class(z)
    if(z.class[1]=="labelled"){
      z.class <- "factor"
    }
    return(z.class)
  }))
  # convert to factor
  for(i in 1:length(vars)){
    if(vars.class[[vars[i]]]!="factor"){
      dt.eval("dat[,",vars[i],":=as.factor(",vars[i],")]")
    }
  }


	# calculate contingency tables
	if(!is.null(conP.var)){
	  if(!is.null(country)){
	    conP <- lapply(country_lev,function(co){
	      dat_co <- dt.eval("dat[",country,"=='",co,"']")
	      lapply(conP.var,function(z){
	        form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
	        dt.eval("xtabs(",form.z,",data=dat_co[,sum(",weights,"),by=list(",year,",",z,")])")
	      })
	    })
	    names(conP) <- country_lev
	  }else{
	    conP <- lapply(conP.var,function(z){
	      form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
	      dt.eval("xtabs(",form.z,",data=dat[,sum(",weights,"),by=list(",year,",",z,")])")
	    })
	  }
	}else{
		conP <- NULL
	}
	if(!is.null(conH.var)){
    if(!is.null(country)){
      dt.eval("dat[,onePerson:=c(1L,rep(0,.N-1)),by=list(",hid,",",year,",",country,")]")
      conH <- lapply(country_lev,function(co){
        dat_co <- dt.eval("dat[",country,"=='",co,"']")
        conH <- lapply(conH.var,function(z){
          form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
          dt.eval("xtabs(",form.z,",data=dat_co[,sum(onePerson*",weights,"),by=list(",year,",",z,")])")
        })
      })
      names(conH) <- country_lev
    }else{
      dt.eval("dat[,onePerson:=c(1L,rep(0,.N-1)),by=list(",hid,",",year,")]")
      conH <- lapply(conH.var,function(z){
        form.z <- paste0("V1~",paste(gsub(",","+",year),z,sep="+"))
        dt.eval("xtabs(",form.z,",data=dat[,sum(onePerson*",weights,"),by=list(",year,",",z,")])")
      })
    }

	}else{
		conH <- NULL
	}


	# define new Index
	new_id <- paste(c(hid,year,country),collapse=",")
	dt.eval("dat[,hidfactor:=factor(paste0(",new_id,"))]")

	# calibrate weights to conP and conH
	select.var <- c("hidfactor",weights,year,country,conP.var,conH.var)
	calib.fail <- c()

  if(!is.null(country)){
	  dat_country <- list()
	  for(co in country_lev){
	    dat_c <- dt.eval("dat[",country,"=='",co,"']")
	    for(g in b.rep){
	      set(dat_c,j=g,value=dt.eval("dat_c[,",g,"*",weights,"]"))

	      # check if margins for bootstrap weights are always positive
	      check.conP <- lapply(conP,function(z){
	        check.z <- dt.eval("dat_c[,sum(",g,"),by=list(",paste(names(dimnames(z)),collapse=","),")][V1==0]")
	        nrow(check.z)>0
	      })
	      check.conH <- lapply(conH,function(z){
	        check.z <- dt.eval("dat_c[,sum(",g,"),by=list(",paste(names(dimnames(z)),collapse=","),")][V1==0]")
	        nrow(check.z)>0
	      })

	      if(any(unlist(c(check.conH,check.conP)))){
	        calib.fail <- c(calib.fail,g)
	        set(dat,j=g,value=NA_real_)
	      }else{
	        set(dat_c,j=g,value=ipu2(dat=copy(dat_c[,mget(c(g,select.var))]),conP=conP[[co]],
	                                 conH=conH[[co]],verbose=verbose,epsP=epsP,epsH=epsH,
	                                 w=g,bound=bound,maxIter=maxIter,meanHH=meanHH,hid="hidfactor"
	                                 # check_hh_vars = check_hh_vars,conversion_messages = conversion_messages # nur für neue ipu2 version
	        )[,calibWeight])
	        if(dat[,any(is.na(get(g)))]){
	          calib.fail <- c(calib.fail,g)
	        }
	      }
	    }
	    dat_country <- c(dat_country,list(dat_c))
	  }
	  dat <- rbindlist(dat_country)
	  rm(dat_country)
	}else{
	  for(g in b.rep){
	    set(dat,j=g,value=dt.eval("dat[,",g,"*",weights,"]"))

	    # check if margins for bootstrap weights are always positive
	    check.conP <- lapply(conP,function(z){
	      check.z <- dt.eval("dat[,sum(",g,"),by=list(",paste(names(dimnames(z)),collapse=","),")][V1==0]")
	      nrow(check.z)>0
	    })
	    check.conH <- lapply(conH,function(z){
	      check.z <- dt.eval("dat[,sum(",g,"),by=list(",paste(names(dimnames(z)),collapse=","),")][V1==0]")
	      nrow(check.z)>0
	    })

	    if(any(unlist(c(check.conH,check.conP)))){
	      calib.fail <- c(calib.fail,g)
	      set(dat,j=g,value=NA_real_)
	    }else{
	      set(dat,j=g,value=ipu2(dat=copy(dat[,mget(c(g,select.var))]),conP=conP,
	                             conH=conH,verbose=verbose,epsP=epsP,epsH=epsH,
	                             w=g,bound=bound,maxIter=maxIter,meanHH=meanHH,hid="hidfactor" #, check_hh_vars = check_hh_vars
	      )[,calibWeight])
	      if(dat[,any(is.na(get(g)))]){
	        calib.fail <- c(calib.fail,g)
	      }
	    }
	  }
	}

	# paste warnings if calibration failed in some instances
	if(length(calib.fail)>0){

	  dat[,c(calib.fail):=NULL]
	  b.rep <- b.rep[!b.rep%in%calib.fail]

	  if(length(b.rep)==0){
	    cat("Calibration failed for bootstrap replicates\n")
	    cat("Returning no bootstrap weights\n")
	  }else{
	    cat("Calibration failed for bootstrap replicates",calib.fail,"\n")
	    cat("Corresponding bootstrap replicates will be discarded\n")
	    lead.char <- sub("[[:digit:]].*","",b.rep[1])
	    b.rep_new <- paste0(lead.char,1:length(b.rep))
	    setnames(dat,b.rep,b.rep_new)
	    cat("Returning",length(b.rep),"calibrated bootstrap weights\n")
	  }
	}


	dat[,hidfactor:=NULL]

	# if(!ipu2new){
	#   # replace the recoded variables by the original ones
	#   if(length(con.var)>0){
	#     for(i in 1:length(con.var)){
	#       isf.i <- paste0(con.var[i],"isfactor")
	#       dt.eval("dat[,",con.var[i],":=",isf.i ,"]")
	#       dt.eval("dat[,",isf.i ,":=NULL]")
	#     }
	#   }
	# }else{
	  # recode vars back to either integer of character
	for(i in 1:length(vars.class)){
	  if(vars.class[i]%in%c("integer","numeric")){
	    dt.eval("dat[,",vars[i],":=as.numeric(as.character(",vars[i],"))]")
	  }else if(vars.class[i]=="character"){
	    dt.eval("dat[,",vars[i],":=as.character(",vars[i],")]")
	  }
	}
	# }

	return(dat)
}


