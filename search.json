[{"path":"https://statistikat.github.io/surveysd/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"The GNU General Public License, Version 2, June 1991 (GPLv2)","title":"The GNU General Public License, Version 2, June 1991 (GPLv2)","text":"Copyright (C) 1989, 1991 Free Software Foundation, Inc. 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://statistikat.github.io/surveysd/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"The GNU General Public License, Version 2, June 1991 (GPLv2)","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://statistikat.github.io/surveysd/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"Terms And Conditions For Copying, Distribution And Modification","title":"The GNU General Public License, Version 2, June 1991 (GPLv2)","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://statistikat.github.io/surveysd/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"No Warranty","title":"The GNU General Public License, Version 2, June 1991 (GPLv2)","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Error estimation","text":"order use dataset calc.stError(), several weight columns present. weight column corresponds bootstrap sample. following examples, use data demo.eusilc() attach bootstrap weights using draw.bootstrap() recalib(). Please refer documentation functions detail.","code":"library(surveysd)  set.seed(1234) eusilc <- demo.eusilc(prettyNames = TRUE) dat_boot <- draw.bootstrap(eusilc, REP = 10, hid = \"hid\", weights = \"pWeight\",                            strata = \"region\", period = \"year\") dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\",                           epsP = 1e-2, epsH = 2.5e-2, verbose = FALSE) dat_boot_calib[, onePerson := nrow(.SD) == 1, by = .(year, hid)]  ## print part of the dataset dat_boot_calib[1:5, .(year, povertyRisk, eqIncome, onePerson, pWeight, w1, w2, w3, w4, w5)] ##     year povertyRisk eqIncome onePerson  pWeight           w1           w2 ##    <num>      <lgcl>    <num>    <lgcl>    <num>        <num>        <num> ## 1:  2010       FALSE 16090.69     FALSE 504.5696 1002.9277771 1003.3969095 ## 2:  2010       FALSE 16090.69     FALSE 504.5696 1002.9277771 1003.3969095 ## 3:  2010       FALSE 16090.69     FALSE 504.5696 1002.9277771 1003.3969095 ## 4:  2010       FALSE 27076.24     FALSE 493.3824    0.4359505    0.4365138 ## 5:  2010       FALSE 27076.24     FALSE 493.3824    0.4359505    0.4365138 ##          w3        w4           w5 ##       <num>     <num>        <num> ## 1: 1023.952 0.4525832 1009.9996015 ## 2: 1023.952 0.4525832 1009.9996015 ## 3: 1023.952 0.4525832 1009.9996015 ## 4: 1000.569 0.4431909    0.4389532 ## 5: 1000.569 0.4431909    0.4389532"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"estimator-functions","dir":"Articles","previous_headings":"","what":"Estimator functions","title":"Error estimation","text":"parameters fun var calc.stError() define estimator used error analysis. two built-estimator functions weightedSum() weightedRatio() can used follows. functions calculate ratio persons risk poverty (percent) total income. default, results calculated separately reference period. Columns use val_ prefix denote point estimate belonging “main weight” dataset, pWeight case dataset used . Columns stE_ prefix denote standard errors calculated bootstrap replicates. replicates result using w1, w2, …, w10 instead pWeight applying estimator. n denotes number observations year N denotes total weight persons.","code":"povertyRate <- calc.stError(dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio) totalIncome <- calc.stError(dat_boot_calib, var = \"eqIncome\", fun = weightedSum) povertyRate$Estimates ## Key: <year, n, N, estimate_type> ##     year     n       N estimate_type val_povertyRisk stE_povertyRisk ##    <num> <int>   <num>        <char>           <num>           <num> ## 1:  2010 14827 8182222        direct        14.44422       0.3564947 ## 2:  2011 14827 8182222        direct        14.77393       0.1896667 ## 3:  2012 14827 8182222        direct        15.04515       0.2102356 ## 4:  2013 14827 8182222        direct        14.89013       0.2333511 ## 5:  2014 14827 8182222        direct        15.14556       0.2928364 ## 6:  2015 14827 8182222        direct        15.53640       0.3932682 ## 7:  2016 14827 8182222        direct        15.08315       0.4459482 ## 8:  2017 14827 8182222        direct        15.42019       0.3646140 totalIncome$Estimates ## Key: <year, n, N, estimate_type> ##     year     n       N estimate_type val_eqIncome stE_eqIncome ##    <num> <int>   <num>        <char>        <num>        <num> ## 1:  2010 14827 8182222        direct 162750998071   1255678643 ## 2:  2011 14827 8182222        direct 161926931417   1349117366 ## 3:  2012 14827 8182222        direct 162576509628   1356155880 ## 4:  2013 14827 8182222        direct 163199507862   1338239449 ## 5:  2014 14827 8182222        direct 163986275009   1045283277 ## 6:  2015 14827 8182222        direct 163416275447   1130824255 ## 7:  2016 14827 8182222        direct 162706205137   1076002926 ## 8:  2017 14827 8182222        direct 164314959107   1379844874"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"custom-estimators","dir":"Articles","previous_headings":"Estimator functions","what":"Custom estimators","title":"Error estimation","text":"order define custom estimator function used fun, function needs least two arguments like example . parameters x w can assumed vectors equal length w numeric weight vector x column defined var argument. called period (case year) weight column (case pWeight, w1, w2, …, w10). Custom estimators using additional parameters can also supplied parameter add.arg can used set additional arguments custom estimator. chunk computes weighted poverty ratio single person households.","code":"## define custom estimator myWeightedSum <- function(x, w) {   sum(x*w) }  ## check if results are equal to the one using `surveysd::weightedSum()` totalIncome2 <- calc.stError(dat_boot_calib, var = \"eqIncome\", fun = myWeightedSum) all.equal(totalIncome$Estimates, totalIncome2$Estimates) ## [1] TRUE ## use add.arg-argument fun <- function(x, w, b) {   sum(x*w*b) } add.arg = list(b=\"onePerson\")  err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\", fun = fun,                         period.mean = 0, add.arg=add.arg) err.est$Estimates ## Key: <year, n, N, estimate_type> ##     year     n       N estimate_type val_povertyRisk stE_povertyRisk ##    <num> <int>   <num>        <char>           <num>           <num> ## 1:  2010 14827 8182222        direct        273683.9       16581.150 ## 2:  2011 14827 8182222        direct        261883.6       13658.303 ## 3:  2012 14827 8182222        direct        243083.9       11650.322 ## 4:  2013 14827 8182222        direct        238004.4       11903.356 ## 5:  2014 14827 8182222        direct        218572.1        7017.085 ## 6:  2015 14827 8182222        direct        219984.1        9238.474 ## 7:  2016 14827 8182222        direct        201753.9        8126.526 ## 8:  2017 14827 8182222        direct        196881.2       11402.497 # compare with direct computation compare.value <- dat_boot_calib[,fun(povertyRisk,pWeight,b=onePerson),                                  by=c(\"year\")] all((compare.value$V1-err.est$Estimates$val_povertyRisk)==0) ## [1] TRUE"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"adjust-variable-depending-on-bootstrap-weights","dir":"Articles","previous_headings":"Estimator functions","what":"Adjust variable depending on bootstrap weights","title":"Error estimation","text":"example variable povertyRisk boolean TRUE income less 60% weighted median income. Thus directly depends original weight vector pWeight. reduce estimated error one calculate bootstrap replicate weight ww weighted median income medIncomewmedIncome_{w} define povertyRiskwpovertyRisk_w $$ povertyRisk_w = \\cases{1 \\quad\\text{Income}<0.6\\cdot medIncome_{w}\\\\                      0 \\quad\\text{else}} $$ estimator can applied new variable povertyRiskwpovertyRisk_w. can realized using custom estimator function. approach shown valid grouping variables supplied (parameter group = NULL). grouping variables supplied one use parameters fun.adjust.var adjust.var povertyRiskwpovertyRisk_w first calculated period used grouping group.","code":"# custom estimator to first derive poverty threshold  # and then estimate a weighted ratio povmd <- function(x, w) {  md <- laeken::weightedMedian(x, w)*0.6  pmd60 <- x < md  # weighted ratio is directly estimated inside the function  return(sum(w[pmd60])/sum(w)*100) }  err.est <- calc.stError(   dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio,   fun.adjust.var = povmd, adjust.var = \"eqIncome\") err.est$Estimates ## Key: <year, n, N, estimate_type> ##     year     n       N estimate_type val_povertyRisk stE_povertyRisk ##    <num> <int>   <num>        <char>           <num>           <num> ## 1:  2010 14827 8182222        direct        14.44422               0 ## 2:  2011 14827 8182222        direct        14.77393               0 ## 3:  2012 14827 8182222        direct        15.04515               0 ## 4:  2013 14827 8182222        direct        14.89013               0 ## 5:  2014 14827 8182222        direct        15.14556               0 ## 6:  2015 14827 8182222        direct        15.53640               0 ## 7:  2016 14827 8182222        direct        15.08315               0 ## 8:  2017 14827 8182222        direct        15.42019               0 # using fun.adjust.var and adjust.var to estimate povmd60 indicator # for each period and bootstrap weight before applying the weightedRatio povmd2 <- function(x, w) {  md <- laeken::weightedMedian(x, w)*0.6  pmd60 <- x < md  return(as.integer(pmd60)) }  # set adjust.var=\"eqIncome\" so the income vector is used to estimate # the povmd60 indicator for each bootstrap weight # and the resulting indicators are passed to function weightedRatio group <- \"gender\" err.est <- calc.stError(   dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio, group = \"gender\",   fun.adjust.var = povmd2, adjust.var = \"eqIncome\") err.est$Estimates ## Key: <year, n, N, gender, estimate_type> ##      year     n       N gender estimate_type val_povertyRisk stE_povertyRisk ##     <num> <int>   <num> <fctr>        <char>           <num>           <num> ##  1:  2010  7267 3979572   male        direct        12.02660       0.4535530 ##  2:  2010  7560 4202650 female        direct        16.73351       0.4177878 ##  3:  2010 14827 8182222   <NA>        direct        14.44422       0.3779383 ##  4:  2011  7267 3979572   male        direct        12.81921       0.2585175 ##  5:  2011  7560 4202650 female        direct        16.62488       0.4977387 ##  6:  2011 14827 8182222   <NA>        direct        14.77393       0.3462408 ##  7:  2012  7267 3979572   male        direct        13.76065       0.4332897 ##  8:  2012  7560 4202650 female        direct        16.26147       0.4395273 ##  9:  2012 14827 8182222   <NA>        direct        15.04515       0.3770204 ## 10:  2013  7267 3979572   male        direct        13.88962       0.5077227 ## 11:  2013  7560 4202650 female        direct        15.83754       0.6758978 ## 12:  2013 14827 8182222   <NA>        direct        14.89013       0.5374978 ## 13:  2014  7267 3979572   male        direct        14.50351       0.4868334 ## 14:  2014  7560 4202650 female        direct        15.75353       0.5176837 ## 15:  2014 14827 8182222   <NA>        direct        15.14556       0.4363345 ## 16:  2015  7267 3979572   male        direct        15.12289       0.3695600 ## 17:  2015  7560 4202650 female        direct        15.92796       0.4978571 ## 18:  2015 14827 8182222   <NA>        direct        15.53640       0.4147613 ## 19:  2016  7267 3979572   male        direct        14.57968       0.4258337 ## 20:  2016  7560 4202650 female        direct        15.55989       0.6436071 ## 21:  2016 14827 8182222   <NA>        direct        15.08315       0.4772674 ## 22:  2017  7267 3979572   male        direct        14.94816       0.5323543 ## 23:  2017  7560 4202650 female        direct        15.86717       0.6709176 ## 24:  2017 14827 8182222   <NA>        direct        15.42019       0.5678174 ##      year     n       N gender estimate_type val_povertyRisk stE_povertyRisk"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"multiple-estimators","dir":"Articles","previous_headings":"Estimator functions","what":"Multiple estimators","title":"Error estimation","text":"case estimator applied several columns dataset, var can set vector containing necessary columns. see relative number persons risk poverty relative number one-person households.","code":"multipleRates <- calc.stError(dat_boot_calib, var = c(\"povertyRisk\", \"onePerson\"), fun = weightedRatio) multipleRates$Estimates ## Key: <year, n, N, estimate_type> ##     year     n       N estimate_type val_povertyRisk stE_povertyRisk ##    <num> <int>   <num>        <char>           <num>           <num> ## 1:  2010 14827 8182222        direct        14.44422       0.3792121 ## 2:  2011 14827 8182222        direct        14.77393       0.2984390 ## 3:  2012 14827 8182222        direct        15.04515       0.3038379 ## 4:  2013 14827 8182222        direct        14.89013       0.2744665 ## 5:  2014 14827 8182222        direct        15.14556       0.4073203 ## 6:  2015 14827 8182222        direct        15.53640       0.5318504 ## 7:  2016 14827 8182222        direct        15.08315       0.3668172 ## 8:  2017 14827 8182222        direct        15.42019       0.4270952 ##    val_onePerson stE_onePerson ##            <num>         <num> ## 1:      14.85737     0.3792121 ## 2:      14.85737     0.2984390 ## 3:      14.85737     0.3038379 ## 4:      14.85737     0.2744665 ## 5:      14.85737     0.4073203 ## 6:      14.85737     0.5318504 ## 7:      14.85737     0.3668172 ## 8:      14.85737     0.4270952"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"grouping","dir":"Articles","previous_headings":"","what":"Grouping","title":"Error estimation","text":"groups argument can used calculate estimators different subsets data. argument can take grouping variable string refers column name (usually factor) dat. set, estimators split reference period also grouping variable. simplicity, one reference period data used. calculate ratio persons risk poverty federal state Austria, group = \"region\" can used. last row region = NA denotes aggregate regions. Note columns N n now show weighted unweighted number persons region.","code":"dat2 <- subset(dat_boot_calib, year == 2010) for (att  in c(\"period\", \"weights\", \"b.rep\"))   attr(dat2, att) <- attr(dat_boot_calib, att) povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio, group = \"region\") povertyRates$Estimates ## Key: <year, n, N, region, estimate_type> ##      year     n       N        region estimate_type val_povertyRisk ##     <num> <int>   <num>        <fctr>        <char>           <num> ##  1:  2010   549  260564    Burgenland        direct        19.53984 ##  2:  2010   733  377355    Vorarlberg        direct        16.53731 ##  3:  2010   924  535451      Salzburg        direct        13.78734 ##  4:  2010  1078  563648     Carinthia        direct        13.08627 ##  5:  2010  1317  701899         Tyrol        direct        15.30819 ##  6:  2010  2295 1167045        Styria        direct        14.37464 ##  7:  2010  2322 1598931        Vienna        direct        17.23468 ##  8:  2010  2804 1555709 Lower Austria        direct        13.84362 ##  9:  2010  2805 1421620 Upper Austria        direct        10.88977 ## 10:  2010 14827 8182222          <NA>        direct        14.44422 ##     stE_povertyRisk ##               <num> ##  1:       3.4977930 ##  2:       1.8429756 ##  3:       1.5296721 ##  4:       1.0009139 ##  5:       1.5894522 ##  6:       1.4839166 ##  7:       1.1834301 ##  8:       1.1854433 ##  9:       0.7033291 ## 10:       0.3564947"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"several-grouping-variables","dir":"Articles","previous_headings":"Grouping","what":"Several grouping variables","title":"Error estimation","text":"case one grouping variable used, several options calling calc.stError() depending whether combinations grouping levels regarded . consider variables gender region grouping variables show three options calc.stError() can called.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"option-1-all-regions-and-all-genders","dir":"Articles","previous_headings":"Grouping > Several grouping variables","what":"Option 1: All regions and all genders","title":"Error estimation","text":"Calculate point estimate standard error region gender. number rows output therefore nperiods⋅(nregions+ngenders+1)=1⋅(9+2+1)=12.n_\\text{periods}\\cdot(n_\\text{regions} + n_\\text{genders} + 1) = 1\\cdot(9 + 2 + 1) = 12. last row estimate whole period.","code":"povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio,                               group = c(\"gender\", \"region\")) povertyRates$Estimates ## Key: <year, n, N, gender, region, estimate_type> ##      year     n       N gender        region estimate_type val_povertyRisk ##     <num> <int>   <num> <fctr>        <fctr>        <char>           <num> ##  1:  2010   549  260564   <NA>    Burgenland        direct        19.53984 ##  2:  2010   733  377355   <NA>    Vorarlberg        direct        16.53731 ##  3:  2010   924  535451   <NA>      Salzburg        direct        13.78734 ##  4:  2010  1078  563648   <NA>     Carinthia        direct        13.08627 ##  5:  2010  1317  701899   <NA>         Tyrol        direct        15.30819 ##  6:  2010  2295 1167045   <NA>        Styria        direct        14.37464 ##  7:  2010  2322 1598931   <NA>        Vienna        direct        17.23468 ##  8:  2010  2804 1555709   <NA> Lower Austria        direct        13.84362 ##  9:  2010  2805 1421620   <NA> Upper Austria        direct        10.88977 ## 10:  2010  7267 3979572   male          <NA>        direct        12.02660 ## 11:  2010  7560 4202650 female          <NA>        direct        16.73351 ## 12:  2010 14827 8182222   <NA>          <NA>        direct        14.44422 ##     stE_povertyRisk ##               <num> ##  1:       3.4977930 ##  2:       1.8429756 ##  3:       1.5296721 ##  4:       1.0009139 ##  5:       1.5894522 ##  6:       1.4839166 ##  7:       1.1834301 ##  8:       1.1854433 ##  9:       0.7033291 ## 10:       0.3183486 ## 11:       0.5171038 ## 12:       0.3564947"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"option-2-all-combinations-of-region-and-gender","dir":"Articles","previous_headings":"Grouping > Several grouping variables","what":"Option 2: All combinations of region and gender","title":"Error estimation","text":"Split data combinations two grouping variables. result larger output-table size nperiods⋅(nregions⋅ngenders+1)=1⋅(9⋅2+1)=19.n_\\text{periods}\\cdot(n_\\text{regions} \\cdot n_\\text{genders} + 1) = 1\\cdot(9\\cdot2 + 1)= 19.","code":"povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio,                               group = list(c(\"gender\", \"region\"))) povertyRates$Estimates ## Key: <year, n, N, gender, region, estimate_type> ##      year     n         N gender        region estimate_type val_povertyRisk ##     <num> <int>     <num> <fctr>        <fctr>        <char>           <num> ##  1:  2010   261  122741.8   male    Burgenland        direct       17.414524 ##  2:  2010   288  137822.2 female    Burgenland        direct       21.432598 ##  3:  2010   359  182732.9   male    Vorarlberg        direct       12.973259 ##  4:  2010   374  194622.1 female    Vorarlberg        direct       19.883637 ##  5:  2010   440  253143.7   male      Salzburg        direct        9.156964 ##  6:  2010   484  282307.3 female      Salzburg        direct       17.939382 ##  7:  2010   517  268581.4   male     Carinthia        direct       10.552149 ##  8:  2010   561  295066.6 female     Carinthia        direct       15.392924 ##  9:  2010   650  339566.5   male         Tyrol        direct       12.857542 ## 10:  2010   667  362332.5 female         Tyrol        direct       17.604861 ## 11:  2010  1128  571011.7   male        Styria        direct       11.671247 ## 12:  2010  1132  774405.4   male        Vienna        direct       15.590616 ## 13:  2010  1167  596033.3 female        Styria        direct       16.964539 ## 14:  2010  1190  824525.6 female        Vienna        direct       18.778813 ## 15:  2010  1363  684272.5   male Upper Austria        direct        9.074690 ## 16:  2010  1387  772593.2 female Lower Austria        direct       16.372949 ## 17:  2010  1417  783115.8   male Lower Austria        direct       11.348283 ## 18:  2010  1442  737347.5 female Upper Austria        direct       12.574206 ## 19:  2010 14827 8182222.0   <NA>          <NA>        direct       14.444218 ##     stE_povertyRisk ##               <num> ##  1:       3.4325893 ##  2:       3.9459427 ##  3:       1.6985123 ##  4:       2.4559616 ##  5:       1.3456351 ##  6:       1.8749742 ##  7:       0.9935549 ##  8:       1.4831758 ##  9:       1.5682812 ## 10:       2.3442053 ## 11:       1.3675880 ## 12:       1.3113885 ## 13:       1.7639890 ## 14:       1.5323126 ## 15:       0.7347478 ## 16:       1.5773296 ## 17:       0.9334914 ## 18:       0.9287010 ## 19:       0.3564947"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"option-3-cobination-of-option-1-and-option-2","dir":"Articles","previous_headings":"Grouping > Several grouping variables","what":"Option 3: Cobination of Option 1 and Option 2","title":"Error estimation","text":"case, estimates standard errors calculated every gender, every region every combination region gender. number rows output therefore nperiods⋅(nregions⋅ngenders+nregions+ngenders+1)=1⋅(9⋅2+9+2+1)=30.n_\\text{periods}\\cdot(n_\\text{regions} \\cdot n_\\text{genders} + n_\\text{regions} + n_\\text{genders} + 1) = 1\\cdot(9\\cdot2 + 9 + 2 + 1) = 30.","code":"povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio,                               group = list(\"gender\", \"region\", c(\"gender\", \"region\"))) povertyRates$Estimates ## Key: <year, n, N, gender, region, estimate_type> ##      year     n         N gender        region estimate_type val_povertyRisk ##     <num> <int>     <num> <fctr>        <fctr>        <char>           <num> ##  1:  2010   261  122741.8   male    Burgenland        direct       17.414524 ##  2:  2010   288  137822.2 female    Burgenland        direct       21.432598 ##  3:  2010   359  182732.9   male    Vorarlberg        direct       12.973259 ##  4:  2010   374  194622.1 female    Vorarlberg        direct       19.883637 ##  5:  2010   440  253143.7   male      Salzburg        direct        9.156964 ##  6:  2010   484  282307.3 female      Salzburg        direct       17.939382 ##  7:  2010   517  268581.4   male     Carinthia        direct       10.552149 ##  8:  2010   549  260564.0   <NA>    Burgenland        direct       19.539837 ##  9:  2010   561  295066.6 female     Carinthia        direct       15.392924 ## 10:  2010   650  339566.5   male         Tyrol        direct       12.857542 ## 11:  2010   667  362332.5 female         Tyrol        direct       17.604861 ## 12:  2010   733  377355.0   <NA>    Vorarlberg        direct       16.537310 ## 13:  2010   924  535451.0   <NA>      Salzburg        direct       13.787343 ## 14:  2010  1078  563648.0   <NA>     Carinthia        direct       13.086268 ## 15:  2010  1128  571011.7   male        Styria        direct       11.671247 ## 16:  2010  1132  774405.4   male        Vienna        direct       15.590616 ## 17:  2010  1167  596033.3 female        Styria        direct       16.964539 ## 18:  2010  1190  824525.6 female        Vienna        direct       18.778813 ## 19:  2010  1317  701899.0   <NA>         Tyrol        direct       15.308190 ## 20:  2010  1363  684272.5   male Upper Austria        direct        9.074690 ## 21:  2010  1387  772593.2 female Lower Austria        direct       16.372949 ## 22:  2010  1417  783115.8   male Lower Austria        direct       11.348283 ## 23:  2010  1442  737347.5 female Upper Austria        direct       12.574206 ## 24:  2010  2295 1167045.0   <NA>        Styria        direct       14.374637 ## 25:  2010  2322 1598931.0   <NA>        Vienna        direct       17.234683 ## 26:  2010  2804 1555709.0   <NA> Lower Austria        direct       13.843623 ## 27:  2010  2805 1421620.0   <NA> Upper Austria        direct       10.889773 ## 28:  2010  7267 3979571.7   male          <NA>        direct       12.026600 ## 29:  2010  7560 4202650.3 female          <NA>        direct       16.733508 ## 30:  2010 14827 8182222.0   <NA>          <NA>        direct       14.444218 ##      year     n         N gender        region estimate_type val_povertyRisk ##     stE_povertyRisk ##               <num> ##  1:       3.4325893 ##  2:       3.9459427 ##  3:       1.6985123 ##  4:       2.4559616 ##  5:       1.3456351 ##  6:       1.8749742 ##  7:       0.9935549 ##  8:       3.4977930 ##  9:       1.4831758 ## 10:       1.5682812 ## 11:       2.3442053 ## 12:       1.8429756 ## 13:       1.5296721 ## 14:       1.0009139 ## 15:       1.3675880 ## 16:       1.3113885 ## 17:       1.7639890 ## 18:       1.5323126 ## 19:       1.5894522 ## 20:       0.7347478 ## 21:       1.5773296 ## 22:       0.9334914 ## 23:       0.9287010 ## 24:       1.4839166 ## 25:       1.1834301 ## 26:       1.1854433 ## 27:       0.7033291 ## 28:       0.3183486 ## 29:       0.5171038 ## 30:       0.3564947 ##     stE_povertyRisk"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"group-differences","dir":"Articles","previous_headings":"","what":"Group differences","title":"Error estimation","text":"differences groups need calculated, e.g difference poverty rates gender = \"male\" gender = \"female\", parameter group.diff can utilised. Setting group.diff = TRUE differences standard error differences variables defined groups calculated. resulting output table contains 49 rows. 12 rows direct estimators nperiods⋅(nregions+ngenders+1)=1⋅(9+2+1)=12,n_\\text{periods}\\cdot(n_\\text{regions} + n_\\text{genders} + 1) = 1\\cdot(9 + 2 + 1) = 12, another 37 differences within variable \"gender\" \"region\" seperately. Variable \"gender\" 2 unique values (unique(dat2$gender)) resulting 1 difference, ~ gender = \"male\" - gender = \"female\" variable \"region\" 9 unique values (unique(dat2$region)) resulting 8+7+6+5+4+3+2+1=∑1=19−1i=368 + 7 + 6 + 5 + 4 + 3 + 2 + 1  = \\sum\\limits_{1=1}^{9-1}= 36 estimates. Thus output contains 1 + 36 = 37 estimates respect group differences. combintaion grouping variables used group group.diff = TRUE differences combinations calculated one grouping variables differs. example difference following groups calculated gender = \"female\" & region = \"Vienna\" - gender = \"male\" & region = \"Vienna\" gender = \"female\" & region = \"Vienna\" - gender = \"female\" & region = \"Salzburg\" gender = \"male\" & region = \"Salzburg\" - gender = \"female\" & region = \"Salzburg\" difference gender = \"female\" & region = \"Vienna\" gender = \"male\" & region = \"Salzburg\" however calculated. Thus leads 2⋅(∑1=19−1i)+9⋅1=812\\cdot(\\sum\\limits_{1=1}^{9-1}) + 9\\cdot1 = 81 results respect differences. Output contains additional column estimate_type ","code":"povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio,                               group = c(\"gender\", \"region\"),                              group.diff = TRUE) povertyRates$Estimates ## Key: <year, n, N, gender, region, estimate_type> ##      year       n         N        gender                        region ##     <num>   <num>     <num>        <fctr>                        <fctr> ##  1:  2010   549.0  260564.0          <NA>                    Burgenland ##  2:  2010   641.0  318959.5          <NA>       Burgenland - Vorarlberg ##  3:  2010   733.0  377355.0          <NA>                    Vorarlberg ##  4:  2010   736.5  398007.5          <NA>         Burgenland - Salzburg ##  5:  2010   813.5  412106.0          <NA>        Burgenland - Carinthia ##  6:  2010   828.5  456403.0          <NA>         Salzburg - Vorarlberg ##  7:  2010   905.5  470501.5          <NA>        Carinthia - Vorarlberg ##  8:  2010   924.0  535451.0          <NA>                      Salzburg ##  9:  2010   933.0  481231.5          <NA>            Burgenland - Tyrol ## 10:  2010  1001.0  549549.5          <NA>          Carinthia - Salzburg ## 11:  2010  1025.0  539627.0          <NA>            Tyrol - Vorarlberg ## 12:  2010  1078.0  563648.0          <NA>                     Carinthia ## 13:  2010  1120.5  618675.0          <NA>              Salzburg - Tyrol ## 14:  2010  1197.5  632773.5          <NA>             Carinthia - Tyrol ## 15:  2010  1317.0  701899.0          <NA>                         Tyrol ## 16:  2010  1422.0  713804.5          <NA>           Burgenland - Styria ## 17:  2010  1435.5  929747.5          <NA>           Burgenland - Vienna ## 18:  2010  1514.0  772200.0          <NA>           Styria - Vorarlberg ## 19:  2010  1527.5  988143.0          <NA>           Vienna - Vorarlberg ## 20:  2010  1609.5  851248.0          <NA>             Salzburg - Styria ## 21:  2010  1623.0 1067191.0          <NA>             Salzburg - Vienna ## 22:  2010  1676.5  908136.5          <NA>    Burgenland - Lower Austria ## 23:  2010  1677.0  841092.0          <NA>    Burgenland - Upper Austria ## 24:  2010  1686.5  865346.5          <NA>            Carinthia - Styria ## 25:  2010  1700.0 1081289.5          <NA>            Carinthia - Vienna ## 26:  2010  1768.5  966532.0          <NA>    Lower Austria - Vorarlberg ## 27:  2010  1769.0  899487.5          <NA>    Upper Austria - Vorarlberg ## 28:  2010  1806.0  934472.0          <NA>                Styria - Tyrol ## 29:  2010  1819.5 1150415.0          <NA>                Tyrol - Vienna ## 30:  2010  1864.0 1045580.0          <NA>      Lower Austria - Salzburg ## 31:  2010  1864.5  978535.5          <NA>      Salzburg - Upper Austria ## 32:  2010  1941.0 1059678.5          <NA>     Carinthia - Lower Austria ## 33:  2010  1941.5  992634.0          <NA>     Carinthia - Upper Austria ## 34:  2010  2060.5 1128804.0          <NA>         Lower Austria - Tyrol ## 35:  2010  2061.0 1061759.5          <NA>         Tyrol - Upper Austria ## 36:  2010  2295.0 1167045.0          <NA>                        Styria ## 37:  2010  2308.5 1382988.0          <NA>               Styria - Vienna ## 38:  2010  2322.0 1598931.0          <NA>                        Vienna ## 39:  2010  2549.5 1361377.0          <NA>        Lower Austria - Styria ## 40:  2010  2550.0 1294332.5          <NA>        Styria - Upper Austria ## 41:  2010  2563.0 1577320.0          <NA>        Lower Austria - Vienna ## 42:  2010  2563.5 1510275.5          <NA>        Upper Austria - Vienna ## 43:  2010  2804.0 1555709.0          <NA>                 Lower Austria ## 44:  2010  2804.5 1488664.5          <NA> Lower Austria - Upper Austria ## 45:  2010  2805.0 1421620.0          <NA>                 Upper Austria ## 46:  2010  7267.0 3979571.7          male                          <NA> ## 47:  2010  7413.5 4091111.0 male - female                          <NA> ## 48:  2010  7560.0 4202650.3        female                          <NA> ## 49:  2010 14827.0 8182222.0          <NA>                          <NA> ##      year       n         N        gender                        region ##        estimate_type val_povertyRisk stE_povertyRisk ##               <char>           <num>           <num> ##  1:           direct     19.53983651       3.4977930 ##  2: group difference      3.00252634       3.9606944 ##  3:           direct     16.53731017       1.8429756 ##  4: group difference      5.75249330       3.4833550 ##  5: group difference      6.45356876       3.6679191 ##  6: group difference     -2.74996696       2.1810428 ##  7: group difference     -3.45104242       2.4430299 ##  8:           direct     13.78734321       1.5296721 ##  9: group difference      4.23164602       3.7840353 ## 10: group difference     -0.70107546       1.9569190 ## 11: group difference     -1.22911968       2.2600547 ## 12:           direct     13.08626775       1.0009139 ## 13: group difference     -1.52084728       2.1872042 ## 14: group difference     -2.22192274       1.7256135 ## 15:           direct     15.30819049       1.5894522 ## 16: group difference      5.16519923       4.4488861 ## 17: group difference      2.30515330       3.1153281 ## 18: group difference     -2.16267289       2.3750967 ## 19: group difference      0.69737304       2.1882875 ## 20: group difference     -0.58729407       2.0891724 ## 21: group difference     -3.44734000       1.6475919 ## 22: group difference      5.69621369       3.6908026 ## 23: group difference      8.65006312       3.5124719 ## 24: group difference     -1.28836953       1.9959639 ## 25: group difference     -4.14841546       1.4050042 ## 26: group difference     -2.69368735       2.6139087 ## 27: group difference     -5.64753678       2.1939450 ## 28: group difference     -0.93355321       2.4923415 ## 29: group difference     -1.92649272       2.3407443 ## 30: group difference      0.05627961       2.1385192 ## 31: group difference      2.89756982       1.8065667 ## 32: group difference     -0.75735506       1.1654850 ## 33: group difference      2.19649436       0.8273904 ## 34: group difference     -1.46456768       1.6146581 ## 35: group difference      4.41841710       1.5622156 ## 36:           direct     14.37463728       1.4839166 ## 37: group difference     -2.86004593       2.0889370 ## 38:           direct     17.23468321       1.1834301 ## 39: group difference     -0.53101447       1.8785787 ## 40: group difference      3.48486389       2.0426535 ## 41: group difference     -3.39106040       1.8009795 ## 42: group difference     -6.34490982       1.4296054 ## 43:           direct     13.84362281       1.1854433 ## 44: group difference      2.95384943       1.4186929 ## 45:           direct     10.88977339       0.7033291 ## 46:           direct     12.02659998       0.3183486 ## 47: group difference     -4.70690810       0.4889135 ## 48:           direct     16.73350808       0.5171038 ## 49:           direct     14.44421817       0.3564947 ##        estimate_type val_povertyRisk stE_povertyRisk povertyRates <- calc.stError(dat2, var = \"povertyRisk\", fun = weightedRatio,                               group = list(c(\"gender\", \"region\")),                              group.diff = TRUE) povertyRates$Estimates[,.N,by=.(estimate_type)] ##       estimate_type     N ##              <char> <int> ## 1:           direct    19 ## 2: group difference    81"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"differences-between-survey-periods","dir":"Articles","previous_headings":"","what":"Differences between survey periods","title":"Error estimation","text":"Differences estimates periods can calculated using parameter period.diff. period.diff expects character vector (NULL) specifying periods differences calcualed . inputs specified form \"period2\" - \"period1\". additional grouping variables supplied calc.stError() die differences across periods also carried variables group.","code":"povertyRates <- calc.stError(dat_boot_calib[year>2013], var = \"povertyRisk\", fun = weightedRatio,                               period.diff = c(\"2017 - 2016\", \"2016 - 2015\", \"2015 - 2014\")) povertyRates$Estimates ## Key: <year, n, N, estimate_type> ##         year     n       N     estimate_type val_povertyRisk stE_povertyRisk ##       <char> <num>   <num>            <char>           <num>           <num> ## 1:      2014 14827 8182222            direct      15.1455601       0.2928364 ## 2:      2015 14827 8182222            direct      15.5364014       0.3932682 ## 3: 2015-2014 14827 8182222 period difference       0.3908413       0.3382182 ## 4:      2016 14827 8182222            direct      15.0831502       0.4459482 ## 5: 2016-2015 14827 8182222 period difference      -0.4532512       0.3523685 ## 6:      2017 14827 8182222            direct      15.4201916       0.3646140 ## 7: 2017-2016 14827 8182222 period difference       0.3370414       0.5114486 povertyRates <- calc.stError(dat_boot_calib[year>2013], var = \"povertyRisk\", fun = weightedRatio,                               group = \"gender\",                              period.diff = c(\"2017 - 2016\", \"2016 - 2015\", \"2015 - 2014\")) povertyRates$Estimates ## Key: <year, n, N, gender, estimate_type> ##          year     n       N gender     estimate_type val_povertyRisk ##        <char> <num>   <num> <fctr>            <char>           <num> ##  1:      2014  7267 3979572   male            direct      14.5035068 ##  2:      2014  7560 4202650 female            direct      15.7535328 ##  3:      2014 14827 8182222   <NA>            direct      15.1455601 ##  4:      2015  7267 3979572   male            direct      15.1228904 ##  5:      2015  7560 4202650 female            direct      15.9279630 ##  6:      2015 14827 8182222   <NA>            direct      15.5364014 ##  7: 2015-2014  7267 3979572   male period difference       0.6193836 ##  8: 2015-2014  7560 4202650 female period difference       0.1744301 ##  9: 2015-2014 14827 8182222   <NA> period difference       0.3908413 ## 10:      2016  7267 3979572   male            direct      14.5796824 ## 11:      2016  7560 4202650 female            direct      15.5598937 ## 12:      2016 14827 8182222   <NA>            direct      15.0831502 ## 13: 2016-2015  7267 3979572   male period difference      -0.5432080 ## 14: 2016-2015  7560 4202650 female period difference      -0.3680693 ## 15: 2016-2015 14827 8182222   <NA> period difference      -0.4532512 ## 16:      2017  7267 3979572   male            direct      14.9481591 ## 17:      2017  7560 4202650 female            direct      15.8671684 ## 18:      2017 14827 8182222   <NA>            direct      15.4201916 ## 19: 2017-2016  7267 3979572   male period difference       0.3684767 ## 20: 2017-2016  7560 4202650 female period difference       0.3072748 ## 21: 2017-2016 14827 8182222   <NA> period difference       0.3370414 ##          year     n       N gender     estimate_type val_povertyRisk ##     stE_povertyRisk ##               <num> ##  1:       0.4025956 ##  2:       0.3488036 ##  3:       0.2928364 ##  4:       0.3717248 ##  5:       0.4562774 ##  6:       0.3932682 ##  7:       0.3032043 ##  8:       0.4755484 ##  9:       0.3382182 ## 10:       0.4734853 ## 11:       0.5475370 ## 12:       0.4459482 ## 13:       0.4463055 ## 14:       0.3986052 ## 15:       0.3523685 ## 16:       0.4088338 ## 17:       0.4226872 ## 18:       0.3646140 ## 19:       0.4772626 ## 20:       0.5659232 ## 21:       0.5114486 ##     stE_povertyRisk"},{"path":"https://statistikat.github.io/surveysd/articles/error_estimation.html","id":"averages-across-periods","dir":"Articles","previous_headings":"","what":"Averages across periods","title":"Error estimation","text":"parameter period.mean averages across periods calculated additional. parameter accepts odd integer values. resulting table contain direct estimates well rolling averages length period.mean. addition parameters group /period.diff specified differences groupings averages calculated.","code":"povertyRates <- calc.stError(dat_boot_calib[year>2013], var = \"povertyRisk\", fun = weightedRatio,                               period.mean = 3) povertyRates$Estimates ## Key: <year, n, N, estimate_type> ##              year     n       N  estimate_type val_povertyRisk stE_povertyRisk ##            <char> <num>   <num>         <char>           <num>           <num> ## 1:           2014 14827 8182222         direct        15.14556       0.2928364 ## 2: 2014_2015_2016 14827 8182222 period average        15.25504       0.3306448 ## 3:           2015 14827 8182222         direct        15.53640       0.3932682 ## 4: 2015_2016_2017 14827 8182222 period average        15.34658       0.3030510 ## 5:           2016 14827 8182222         direct        15.08315       0.4459482 ## 6:           2017 14827 8182222         direct        15.42019       0.3646140 povertyRates <- calc.stError(dat_boot_calib[year>2013], var = \"povertyRisk\", fun = weightedRatio,                               period.mean = 3, period.diff = \"2016 - 2015\",                              group = \"gender\") povertyRates$Estimates ## Key: <year, n, N, gender, estimate_type> ##               year     n       N gender                      estimate_type ##             <char> <num>   <num> <fctr>                             <char> ##  1:           2014  7267 3979572   male                             direct ##  2:           2014  7560 4202650 female                             direct ##  3:           2014 14827 8182222   <NA>                             direct ##  4: 2014_2015_2016  7267 3979572   male                     period average ##  5: 2014_2015_2016  7560 4202650 female                     period average ##  6: 2014_2015_2016 14827 8182222   <NA>                     period average ##  7:           2015  7267 3979572   male                             direct ##  8:           2015  7560 4202650 female                             direct ##  9:           2015 14827 8182222   <NA>                             direct ## 10: 2015_2016_2017  7267 3979572   male                     period average ## 11: 2015_2016_2017  7560 4202650 female                     period average ## 12: 2015_2016_2017 14827 8182222   <NA>                     period average ## 13:           2016  7267 3979572   male                             direct ## 14:           2016  7560 4202650 female                             direct ## 15:           2016 14827 8182222   <NA>                             direct ## 16:      2016-2015  7267 3979572   male                  period difference ## 17:      2016-2015  7560 4202650 female                  period difference ## 18:      2016-2015 14827 8182222   <NA>                  period difference ## 19: 2016-2015_mean  7267 3979572   male difference between period averages ## 20: 2016-2015_mean  7560 4202650 female difference between period averages ## 21: 2016-2015_mean 14827 8182222   <NA> difference between period averages ## 22:           2017  7267 3979572   male                             direct ## 23:           2017  7560 4202650 female                             direct ## 24:           2017 14827 8182222   <NA>                             direct ##               year     n       N gender                      estimate_type ##     val_povertyRisk stE_povertyRisk ##               <num>           <num> ##  1:     14.50350682       0.4025956 ##  2:     15.75353283       0.3488036 ##  3:     15.14556006       0.2928364 ##  4:     14.73535987       0.3659977 ##  5:     15.74712982       0.3825653 ##  6:     15.25503720       0.3306448 ##  7:     15.12289042       0.3717248 ##  8:     15.92796296       0.4562774 ##  9:     15.53640136       0.3932682 ## 10:     14.88357729       0.3156388 ## 11:     15.78500836       0.3738618 ## 12:     15.34658105       0.3030510 ## 13:     14.57968239       0.4734853 ## 14:     15.55989368       0.5475370 ## 15:     15.08315018       0.4459482 ## 16:     -0.54320803       0.4463055 ## 17:     -0.36806928       0.3986052 ## 18:     -0.45325118       0.3523685 ## 19:      0.14821741       0.1635540 ## 20:      0.03787854       0.1680536 ## 21:      0.09154385       0.1508342 ## 22:     14.94815906       0.4088338 ## 23:     15.86716845       0.4226872 ## 24:     15.42019160       0.3646140 ##     val_povertyRisk stE_povertyRisk"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Iterative Proportional Fitting","text":"assume output demo.eusilc() population. population, sample without replacement drawn. sample covers 10 percent population. assign weight one observations population weight ten observations sample.","code":"library(surveysd) population <- demo.eusilc(1, prettyNames = TRUE) population[, pWeight := 1] pop_sample <- population[sample(1:.N, floor(.N*0.10)), ] pop_sample[, pWeight := 10]"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"one-constraint-one-variable","dir":"Articles","previous_headings":"","what":"One constraint, one variable","title":"Iterative Proportional Fitting","text":"start example want adapt weights pop_sample weighted number males females matches ones population. can see currently case. Due random sampling (rather stratified sampling), differences gender distributions. can pass gender_distribution parameter ipf() obtain modified weights. resulting dataset, pop_sample_c similar pop_sample additional column adjusted weights. can now calculate weighted number males females according new weight. result match constraints. simple case, ipf just performs post stratification step. means, males females weight. males weighted (calibWeight < 10) compensate overrepresentation sample.","code":"(gender_distribution <- xtabs(pWeight ~ gender, population)) #> gender #>   male female  #>   7267   7560 xtabs(pWeight ~ gender, pop_sample) #> gender #>   male female  #>   7380   7440 pop_sample_c <- ipf(pop_sample, conP = list(gender_distribution), w = \"pWeight\") dim(pop_sample) #> [1] 1482   30 dim(pop_sample_c) #> [1] 1482   31 setdiff(names(pop_sample_c), names(pop_sample)) #> [1] \"calibWeight\" xtabs(calibWeight ~ gender, pop_sample_c) #> gender #>   male female  #>   7267   7560 xtabs(pWeight ~ gender, population) #> gender #>   male female  #>   7267   7560 xtabs(~ calibWeight + gender, pop_sample_c) #>                   gender #> calibWeight        male female #>   9.84688346883469  738      0 #>   10.1612903225806    0    744"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"one-constraint-two-variables","dir":"Articles","previous_headings":"","what":"One constraint, two variables","title":"Iterative Proportional Fitting","text":"Let’s now assume want put constraints number males females age group. numbers original population can obtained xtabs(). , can see constraints met. Supplying contingency table con_ga ipf() resolve .","code":"(con_ga <- xtabs(pWeight ~ gender + age, population)) #>         age #> gender   (-Inf,16] (16,25] (25,45] (45,65] (65, Inf] #>   male        1528     855    2165    1822       897 #>   female      1375     848    2255    1845      1237 xtabs(pWeight ~ gender + age, pop_sample) #>         age #> gender   (-Inf,16] (16,25] (25,45] (45,65] (65, Inf] #>   male        1480     870    2310    1830       890 #>   female      1620     780    2180    1690      1170 pop_sample_c2 <- ipf(pop_sample, conP = list(con_ga), w = \"pWeight\") xtabs(pWeight ~ gender + age, population) #>         age #> gender   (-Inf,16] (16,25] (25,45] (45,65] (65, Inf] #>   male        1528     855    2165    1822       897 #>   female      1375     848    2255    1845      1237 xtabs(calibWeight ~ gender + age, pop_sample_c2) #>         age #> gender   (-Inf,16] (16,25] (25,45] (45,65] (65, Inf] #>   male        1528     855    2165    1822       897 #>   female      1375     848    2255    1845      1237"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"two-constraints","dir":"Articles","previous_headings":"","what":"Two constraints","title":"Iterative Proportional Fitting","text":"Now assume know number persons living nuts2 region registry data. However, registry data provide information age gender. Therefore, two contingency tables (con_ga registry_table) specified independently. can done supplying list conP time, constraints matched perfectly. , provided one constraint. therefore, ipf() algorithm work iteratively.","code":"registry_table <- xtabs(pWeight ~ region, population) pop_sample_c2 <- ipf(pop_sample, conP = list(con_ga, registry_table), w = \"pWeight\") xtabs(pWeight ~ gender + age, population) #>         age #> gender   (-Inf,16] (16,25] (25,45] (45,65] (65, Inf] #>   male        1528     855    2165    1822       897 #>   female      1375     848    2255    1845      1237 xtabs(calibWeight ~ gender + age, pop_sample_c2) #>         age #> gender   (-Inf,16]   (16,25]   (25,45]   (45,65] (65, Inf] #>   male   1528.0003  854.9994 2164.9996 1821.9998  897.0004 #>   female 1374.9999  847.9999 2255.0012 1845.0003 1236.9992 xtabs(pWeight ~ region, population) #> region #>    Burgenland     Carinthia Lower Austria      Salzburg        Styria  #>           549          1078          2804           924          2295  #>         Tyrol Upper Austria        Vienna    Vorarlberg  #>          1317          2805          2322           733 xtabs(calibWeight ~ region, pop_sample_c2) #> region #>    Burgenland     Carinthia Lower Austria      Salzburg        Styria  #>           549          1078          2804           924          2295  #>         Tyrol Upper Austria        Vienna    Vorarlberg  #>          1317          2805          2322           733"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"household-constraints","dir":"Articles","previous_headings":"","what":"Household Constraints","title":"Iterative Proportional Fitting","text":"dataset household structure, household constraints can passed via parameter conH. parameter used, also necessary supply hid, defines column names contains household ids.","code":"(conH1 <- xtabs(pWeight ~ hsize + region, data = population[!duplicated(hid)])) #>      region #> hsize Burgenland Carinthia Lower Austria Salzburg Styria Tyrol Upper Austria #>     1         58       117           325      103    264   118           262 #>     2         82       126           345      102    260   149           321 #>     3         37        80           189       55    187    79           203 #>     4         33        63           169       71    122   102           168 #>     5         16        39           103       30     83    48           114 #>      region #> hsize Vienna Vorarlberg #>     1    431         67 #>     2    355         72 #>     3    175         44 #>     4     96         53 #>     5     50         34 pop_sample_hh <- ipf(pop_sample, hid = \"hid\", conH = list(conH1), w = \"pWeight\",                      bound = 10) xtabs(calibWeight ~ hsize + region, data = pop_sample_hh[!duplicated(hid)]) #>      region #> hsize Burgenland Carinthia Lower Austria Salzburg Styria Tyrol Upper Austria #>     1         58       117           325      103    264   118           262 #>     2         82       126           345      102    260   149           321 #>     3         37        80           189       55    187    79           203 #>     4         33        63           169       71    122   102           168 #>     5         16        39           103       30     83    48           114 #>      region #> hsize Vienna Vorarlberg #>     1    431         67 #>     2    355         72 #>     3    175         44 #>     4     96         53 #>     5     50         34"},{"path":"https://statistikat.github.io/surveysd/articles/ipf.html","id":"tolerances","dir":"Articles","previous_headings":"","what":"Tolerances","title":"Iterative Proportional Fitting","text":"conP conH contain several contingency tables conP conH used time, ipf algorithm operate iteratively. means calibrated dataset satisfy constraints approximately. default tolerances approximation can overwritten using parameters conP conH. Lowering tolerances improve match constraints contingency tables according calibrated weights. However, lower tolerances also make iterations necessary convergence met. constraints small, ipf return warning indicates convergence reached. see changing tolerances 0.01 (one percent) 0.0001 increases number required iterations.","code":"ipf(pop_sample, conP = list(con_ga, registry_table), w = \"pWeight\",     verbose = TRUE, epsP = 0.01) #> Iteration stopped after 3 steps #> Convergence reached ipf(pop_sample, conP = list(con_ga, registry_table), w = \"pWeight\",     verbose = TRUE, epsP = 0.0001) #> Iteration stopped after 3 steps #> Convergence reached"},{"path":[]},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"bootstrapping","dir":"Articles","previous_headings":"","what":"Bootstrapping","title":"Methodology","text":"Bootstrapping long around used widely estimate confidence intervals standard errors point estimates.[Efron (1979)} Given random sample (X1,…,Xn)(X_1,\\ldots,X_n) drawn unknown distribution FF distribution point estimate θ(X1,…,Xn;F)\\theta(X_1,\\ldots,X_n;F) can many cases determined analytically. However using bootstrapping one can simulate distribution θ\\theta. Let s(.)s_{(.)} bootstrap sample, e.g. drawing nn observations replacement sample (X1,…,Xn)(X_1,\\ldots,X_n), one can estimate standard deviation θ\\theta using BB bootstrap samples sd(θ)=1B−1∑=1B(θ(si)−θ¯)2,sd(\\theta) = \\sqrt{\\frac{1}{B-1}\\sum\\limits_{=1}^B (\\theta(s_i)-\\overline{\\theta})^2} \\quad, θ¯:=1B∑=1Bθ(si)\\overline{\\theta}:=\\frac{1}{B}\\sum\\limits_{=1}^B\\theta(s_i) sample mean bootstrap samples. context sample surveys sampling weights one can use bootstrapping calculate called bootstrap weights. computed via bootstrap samples sis_{}, =1,…,Bi=1,\\ldots,B, sis_{} every unit original sample can appear 00- mm-times. fjif_j^{} frequency occurrence observation jj bootstrap sample sis_i uncalibrated bootstrap weights b̃ji\\tilde{b}_{j}^{} defined : b̃ji=fjiwj,   \\tilde{b}_{j}^{} = f_j^{} w_j \\quad, wjw_j calibrated sampling weight original sample. Using iterative proportional fitting procedures one can recalibrate bootstrap weights b̃j.\\tilde{b}_{j}^{.}, j=1,…,Bj=1,\\ldots,B get adapted calibrated bootstrap weights bjib_j^, j=1,…,Bj=1,\\ldots,B.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"rescaled-bootstrap","dir":"Articles","previous_headings":"Bootstrapping","what":"Rescaled Bootstrap","title":"Methodology","text":"Since EU-SILC stratified sample without replacement drawn finite population naive bootstrap procedure, described , take account heterogeneous inclusion probabilities sample unit. Thus yield satisfactory results. Therefore use called rescaled bootstrap procedure introduced investigated (Rao Wu 1988). bootstrap samples selected without replacement incorporate stratification well clustering multiple stages (see (Chipperfield Preston 2007),(Preston 2009)). simplistic reasons describe rescaled bootstrap procedure two stage stratified sampling design. details general formulation please see (Preston 2009).","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"sampling-design","dir":"Articles","previous_headings":"Bootstrapping","what":"Sampling design","title":"Methodology","text":"Consider finite population UU divided HH non-overlapping strata ⋃h=1,…,HUh=U\\bigcup\\limits_{h=1,\\ldots,H} U_h = U, strata hh contains NhN_h clusters. strata hh, ChcC_{hc}, c=1,…,nhc=1,\\ldots,n_h clusters drawn, containing NhcN_{hc} households. Furthermore cluster ChcC_{hc} strata hh simple random sampling performed select set households YhcjY_{hcj}, j=1,…,nhcj=1,\\ldots,n_{hc}.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"bootstrap-procedure","dir":"Articles","previous_headings":"Bootstrapping","what":"Bootstrap procedure","title":"Methodology","text":"contrast naive bootstrap procedure stage, containing nn sampling units, bootstrap replicate obtained drawing nn sampling units replacement, rescaled bootstrap procedure n*=⌊n2⌋n^*=\\left\\lfloor\\frac{n}{2}\\right\\rfloor sampling units drawn without replacement. Given value xx, ⌊x⌋\\lfloor x\\rfloor denotes largest integer smaller xx, whereas ⌈x⌉\\lceil x\\rceil denotes smallest integer lager xx. (Chipperfield Preston 2007) shown choice either ⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor ⌈n2⌉\\left\\lceil\\frac{n}{2}\\right\\rceil optimal bootstrap samples without replacement, although ⌊n2⌋\\left\\lfloor\\frac{n}{2}\\right\\rfloor desirable property resulting uncalibrated bootstrap weights never negative. first stage ii-th bootstrap replicate, fhci,1f^{,1}_{hc}, cluster ChcC_{hc},c=1,…,nhc=1,\\ldots,n_h, belonging strata hh, defined fhci,1=1−λh+λhnhnh*δhc∀c∈{1,…,nh}   f^{,1}_{hc} = 1-\\lambda_h+\\lambda_h\\frac{n_h}{n_h^*}\\delta_{hc} \\quad\\quad \\forall c \\\\{1,\\ldots,n_h\\}   nh*=⌊nh2⌋   n_h^* = \\left\\lfloor\\frac{n_h}{2}\\right\\rfloor λh=nh*(1−nhNh)nh−nh*,   \\lambda_h = \\sqrt{\\frac{n_h^*(1-\\frac{n_h}{N_h})}{n_h-n_h^*}} \\quad , δhc=1\\delta_{hc}=1 cluster cc selected sub-sample size nh*n_h^* 0 otherwise. ii-th bootstrap replicate second stage, fhcji,2f^{,2}_{hcj}, household YhcjY_{hcj}, j=1,…,nhcj=1,\\ldots,n_{hc}, belonging cluster cc strata hh defined fhcji,2=fhci,1−λhcnhnh*δhc[nhcnhc*δhcj−1]∀c∈{1,…,nh}   f^{,2}_{hcj} = f^{,1}_{hc} - \\lambda_{hc}\\sqrt{\\frac{n_h}{n_h^*}}\\delta_{hc}\\left[\\frac{n_{hc}}{n_{hc}^*}\\delta_{hcj}-1\\right] \\quad\\quad \\forall c \\\\{1,\\ldots,n_h\\}  nhc*=⌊nhc2⌋   n_{hc}^* = \\left\\lfloor\\frac{n_{hc}}{2}\\right\\rfloor  λhc=nhc*Nh(1−nhcNhc)nhc−nhc*,   \\lambda_{hc} = \\sqrt{\\frac{n_{hc}^*N_h(1-\\frac{n_{hc}}{N_{hc}})}{n_{hc}-n_{hc}^*}} \\quad , δhcj=1\\delta_{hcj}=1 household jj selected sub sample size nhc*n_{hc}^* 0 otherwise.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"single-psus","dir":"Articles","previous_headings":"Bootstrapping","what":"Single PSUs","title":"Methodology","text":"dealing multistage sampling designs issue single PSUs, e.g. single response unit present stage strata, can occur. applying bootstrapping procedures single PSUs can lead variety issues. methodology proposed work combined single PSUs stage next smallest strata cluster, applying bootstrap procedure.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"taking-bootstrap-replicates-forward","dir":"Articles","previous_headings":"Bootstrapping","what":"Taking bootstrap replicates forward","title":"Methodology","text":"bootstrap procedure applied EU-SILC data year yty_t, t=1,…,nyt=1,\\ldots,n_y separately. Since EU-SILC yearly survey rotating penal design ii-th bootstrap replicate second stage, fhcji,2f^{,2}_{hcj}, household YhcjY_{hcj} taken forward household YhcjY_{hcj} drops sample. , household YhcjY_{hcj}, enters EU-SILC year y1y_1 drops year yt̃y_{\\tilde{t}}, bootstrap replicates years y2,…,yt̃y_2,\\ldots,y_{\\tilde{t}} set bootstrap replicate year y1y_1.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"split-households","dir":"Articles","previous_headings":"Bootstrapping","what":"Split households","title":"Methodology","text":"Due rotating penal design called split households can occur. household participating EU-SILC survey possible one residents move new called split household, followed next wave. take dynamic account extended procedure taking forward bootstrap replicate household consecutive waves EU-SILC taking forward bootstrap replicate split household. means, also new individuals split household inherit bootstrap replicate. Taking bootstrap replicates forward well considering split households ensures bootstrap replicates comparable structure actual design EU-SILC.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"uncalibrated-bootstrap-weights","dir":"Articles","previous_headings":"Bootstrapping","what":"Uncalibrated bootstrap weights","title":"Methodology","text":"Using ii-th bootstrap replicates second stage one can calculate ii-th uncalibrated bootstrap weights bhcjib_{hcj}^{} household YhcjY_{hcj} cluster cc contained strata hh b̃hcji=fhcji,2whcj,   \\tilde{b}_{hcj}^{} = f^{,2}_{hcj} w_{hcj} \\quad,  whcjw_{hcj} corresponds original household weight contained sample. ease readability drop subindices regarding strata hh cluster cc following sections, meaning jj-th household cluster cc contained strata hh, YhcjY_{hcj}, now denoted jj-th household, YjY_{j}, jj position household data. accordance ii-th uncalibrated bootstrap replicates household jj thus denoted b̃ji\\tilde{b}_j^{} original household weight wjw_j.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"iterative-proportional-fitting-ipf","dir":"Articles","previous_headings":"","what":"Iterative proportional fitting (IPF)","title":"Methodology","text":"uncalibrated bootstrap weights b̃ji\\tilde{b}_j^{} computed rescaled bootstrap procedure yields population statistics differ known population margins specified sociodemographic variables base weights wjw_j calibrated. adjust bootstrap weights b̃ji\\tilde{b}_{j}^{} can recalibrated using iterative proportional fitting described (Meraner, Gumprecht, Kowarik 2016). Let original weight wjw_{j} calibrated n=nP+nHn=n_P+n_H sociodemographic variables divided sets 𝒫:={pc,c=1…,nP}\\mathcal{P}:=\\{p_{c}, c=1 \\ldots,n_P\\} ℋ:={hc,c=1…,nH}\\mathcal{H}:=\\{h_{c}, c=1 \\ldots,n_H\\}. 𝒫\\mathcal{P} ℋ\\mathcal{H} correspond personal, example gender age, household variables, like region households size, respectively. variable either 𝒫\\mathcal{P} ℋ\\mathcal{H} can take PcP_{c} HcH_{c} values NvpcN^{p_c}_v, v=1,…,Pcv=1,\\ldots,P_c, NvhcN^{h_c}_v, v=1,…,Hcv=1,\\ldots,H_c, corresponding population margins. Starting k=0k=0 iterative proportional fitting procedure applied b̃ji\\tilde{b}_j^{}, =1,…,Bi=1,\\ldots, B separately. weights first updated personal afterwards updated household variables. constraints regarding populations margins met kk raised 1 procedure starts beginning. following denote starting weight b̃j[0]:=b̃ji\\tilde{b}_j^{[0]}:=\\tilde{b}_j^{} fixed ii.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"adjustment-and-trimming-for-mathcalp","dir":"Articles","previous_headings":"Iterative proportional fitting (IPF)","what":"Adjustment and trimming for 𝒫\\mathcal{P}","title":"Methodology","text":"uncalibrated bootstrap weight b̃j[(n+1)k+c−1]\\tilde{b}_j^{[(n+1)k+c-1]} jj-th observation iteratively multiplied factor projected distribution population matches respective calibration specification NpcN_{p_c}, c=1,…,nPc=1, \\ldots,n_P. c∈{1,…,nP}c \\\\left\\{1, \\ldots,n_P\\right\\} calibrated weights NvpcN^{p_c}_v computed b̃j[(n+1)k+c]=b̃j[(n+1)k+c−1]Nvpc∑lb̃l[(n+1)k+c−1],   \\tilde{b}_j^{[(n+1)k+c]} = {\\tilde{b}_j}^{[(n+1)k+c-1]}\\frac{N^{p_c}_v}{{\\sum\\limits_l} {\\tilde{b}}_l^{[(n+1)k+c-1]}},  summation denominator expands observations value observation jj sociodemographic variable pcp_c. weights b̃j[nk+c]\\tilde{b}_j^{[nk+c]} fall outside range [wj4;4wj]\\left[\\frac{w_j}{4};4w_j\\right] recoded nearest two boundaries. choice boundaries results expert-based opinions restricts variance positive effect sampling error. procedure represents common form weight trimming large small weights trimmed order reduce variance exchange possible increase bias ((Potter 1990),(Potter 1993)).","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"averaging-weights-within-households","dir":"Articles","previous_headings":"Iterative proportional fitting (IPF)","what":"Averaging weights within households","title":"Methodology","text":"Since sociodemographic variables p1,…,pncp_1,\\ldots,p_{n_c} include person-specific variables, weights b̃j[nk+np]\\tilde{b}_j^{[nk+n_p]} resulting iterative multiplication can unequal members household. can lead inconsistencies results projected household person weights. avoid inconsistencies household member assigned mean household weights. person jj household aa hah_a household members, weights defined b̃j[(n+1)k+np+1]=∑l∈ab̃l[(n+1)k+np]ha   \\tilde{b}_j^{[(n+1)k+n_p+1]} = \\frac{{\\sum\\limits_{l\\}} {\\tilde{b}_l^{[(n+1)k+n_p]}}}{h_a}  can result losing population structure performed previous subsection.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"adjustment-and-trimming-for-mathcalh","dir":"Articles","previous_headings":"Iterative proportional fitting (IPF)","what":"Adjustment and trimming for ℋ\\mathcal{H}","title":"Methodology","text":"adjustment individual variables weights bj[nk+np+1]b_j^{[nk+n_p+1]} updated set household variables ℋ\\mathcal{H} according household convergence constraint parameter ϵh\\epsilon_h. parameters ϵh\\epsilon_h represent allowed deviation population margins using weights bj[nk+np+1]b_j^{[nk+n_p+1]} compared NvhcN^{h_c}_v, c=1,…,nHc=1,\\ldots,n_H, v=1,…,Hcv=1,\\ldots,H_c. updated weights computed bj[(n+1)k+np+c+1]={bj[(n+1)k+np+1]Nvhc∑lbl[(n+1)k+np+1]∑lbj[(n+1)k+np+1]∉((1−0.9ϵh)Nvhc,(1+0.9ϵh)Nvhc)bj[(n+1)k+np+1]otherwise   b_j^{[(n+1)k+n_p+c+1]} =   \\begin{cases}     b_j^{[(n+1)k+n_p+1]}\\frac{N^{h_c}_v}{\\sum\\limits_{l} b_l^{[(n+1)k+n_p+1]}} \\quad \\text{} \\sum\\limits_{l} b_j^{[(n+1)k+n_p+1]} \\notin ((1-0.9\\epsilon_h)N^{h_c}_v,(1+0.9\\epsilon_h)N^{h_c}_v) \\\\     b_j^{[(n+1)k+n_p+1]} \\quad \\text{otherwise}   \\end{cases}  summation denominator ranging households ll take values hch_c observation jj. described previous subsection new weight recoded exceed interval [wj4;4wj][\\frac{w_j}{4};4w_j] set upper lower bound, depending bj[(n+1)k+np+c+1]b_j^{[(n+1)k+n_p+c+1]} falls interval respectively.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"convergence","dir":"Articles","previous_headings":"Iterative proportional fitting (IPF)","what":"Convergence","title":"Methodology","text":"adjustment trimming step factor Nv(.)∑lbl[(n+1)k+j]\\frac{N^{(.)}_v}{\\sum\\limits_{l} b_l^{[(n+1)k+j]}}, j∈{1,…,n+1}∖{np+1}j\\\\{1,\\ldots,n+1\\}\\backslash \\{n_p+1\\}, checked convergence constraints households, ϵh\\epsilon_h, personal variables ϵp\\epsilon_p, (.)(.) corresponds either household personal variable. precise variables 𝒫\\mathcal{P} constraints Nvpc∑lb̃l[(n+1)k+j]∈((1−ϵp)Nvpc,(1+ϵp)Nvpc) \\frac{N^{p_c}_v}{{\\sum\\limits_l} {\\tilde{b}}_l^{[(n+1)k+j]}} \\((1-\\epsilon_p)N^{p_c}_v,(1+\\epsilon_p)N^{p_c}_v)  variables ℋ\\mathcal{H} constraints Nvhc∑lb̃l[(n+1)k+j]∈((1−ϵh)Nvhc,(1+ϵh)Nvhc) \\frac{N^{h_c}_v}{{\\sum\\limits_l} {\\tilde{b}}_l^{[(n+1)k+j]}} \\((1-\\epsilon_h)N^{h_c}_v,(1+\\epsilon_h)N^{h_c}_v)  verified, sum denominator expands observations value variables hch_c pcp_c. constraints hold true algorithm reaches convergence, otherwise kk raised 1 procedure repeats . described calibration procedure applied year yty_t EU-SILC separately, t=1,…nyt=1,\\ldots n_y, thus resulting called calibrated bootstrap sample weights bj(,yt)b_{j}^{(,{y_t})}, =1,…,Bi=1,\\ldots,B year yy household jj.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/methodology.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance estimation","title":"Methodology","text":"Applying previously described algorithms EU-SILC data multiple consecutive years yty_t, t=1,…nyt=1,\\ldots n_y, yields calibrated bootstrap sample weights bj(,yt)b_{j}^{(,{y_t})} year yty_t. Using calibrated bootstrap sample weights straight forward compute standard error point estimate θ(𝐗yt,𝐰yt)\\theta(\\textbf{X}^{y_t},\\textbf{w}^{y_t}) year yty_t 𝐗yt=(X1yt,…,Xnyt)\\textbf{X}^{y_t}=(X_1^{y_t},\\ldots,X_n^{y_t}) vector observations variable interest survey 𝐰yt=(w1yt,…,wnyt\\textbf{w}^{y_t}=(w_1^{y_t},\\ldots,w_n^{y_t} corresponding weight vector, sd(θ)=1B−1∑=1B(θ(,yt)−θ(.,yt)¯)2   sd(\\theta) = \\sqrt{\\frac{1}{B-1}\\sum\\limits_{=1}^B (\\theta^{(,y_t)}-\\overline{\\theta^{(.,y_t)}})^2}   θ(.,yt)¯=1B∑=1Bθ(,yt),   \\overline{\\theta^{(.,y_t)}} = \\frac{1}{B}\\sum\\limits_{=1}^B\\theta^{(,y_t)} \\quad,  θ(,yt):=θ(𝐗yt,𝐛(,yt))\\theta^{(,y_t)}:=\\theta(\\textbf{X}^{y_t},\\textbf{b}^{(,{y_t})}) estimate θ\\theta year yty_t using ii-th vector calibrated bootstrap weights. already mentioned standard error estimation indicators EU-SILC yields high quality results NUTS1 country level. estimation indicators regional sub-aggregate levels one confronted point estimates yielding high variance. overcome issue propose estimate θ\\theta 3, consecutive years using calibrated bootstrap weights, thus calculating {θ(,yt−1),θ(,yt),θ(,yt+1)}\\{\\theta^{(,y_{t-1})},\\theta^{(,y_t)},\\theta^{(,y_{t+1})}\\}, =1,…,Bi=1,\\ldots,B. fixed ii one can apply filter equal filter weights time series {θ(,yt−1),θ(,yt),θ(,yt+1)}\\{\\theta^{(,y_{t-1})},\\theta^{(,y_t)},\\theta^{(,y_{t+1})}\\} create θ̃(,yt)\\tilde{\\theta}^{(,y_t)} θ̃(,yt)=13[θ(,yt−1)+θ(,yt)+θ(,yt+1)].   \\tilde{\\theta}^{(,y_t)} = \\frac{1}{3}\\left[\\theta^{(,y_{t-1})}+\\theta^{(,y_t)}+\\theta^{(,y_{t+1})}\\right] \\quad . ii, =1,…,Bi=1,\\ldots,B, yields θ̃(,yt)\\tilde{\\theta}^{(,y_t)}, =1,…,Bi=1,\\ldots,B. standard error θ\\theta can estimated sd(θ)=1B−1∑=1B(θ̃(,yt)−θ̃(.,yt)¯)2   sd(\\theta) = \\sqrt{\\frac{1}{B-1}\\sum\\limits_{=1}^B (\\tilde{\\theta}^{(,y_t)}-\\overline{\\tilde{\\theta}^{(.,y_t)}})^2}  θ̃(.,yt)¯=1B∑=1Bθ̃(,yt).   \\overline{\\tilde{\\theta}^{(.,y_t)}}=\\frac{1}{B}\\sum\\limits_{=1}^B\\tilde{\\theta}^{(,y_t)} \\quad. Applying filter time series estimated θ(,yt)\\theta^{(,y_t)} leads reduction variance θ\\theta since filter reduces noise {θ(,yt−1),θ(,yt),θ(,yt+1)}\\{\\theta^{(,y_{t-1})},\\theta^{(,y_t)},\\theta^{(,y_{t+1})}\\} thus leading narrow distribution θ̃(,yt)\\tilde{\\theta}^{(,y_t)}. also noted estimating indicators survey rotating panel design general straight forward high correlation consecutive years. However approach use bootstrap weights, independent , can bypass cumbersome calculation various correlations, apply directly estimate standard error. (Bauer et al. 2013) showed using proposed method EU-SILC data Austria reduction resulting standard errors corresponds theoretical increase sample size 25%\\%. Furthermore study compared method use small area estimation techniques average use bootstrap sample weights yielded stable results.","code":""},{"path":[]},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"mathematical-formulation","dir":"Articles","previous_headings":"","what":"Mathematical Formulation","title":"Rao-Wu Bootstrap in surveysd","text":"formally, replicate weights constructed follows: whi*=(1−λh+λh⋅nhmh⋅rhi*)⋅whi w^*_{hi} = \\left(1 - \\lambda_h + \\lambda_h \\cdot \\frac{n_h}{m_h} \\cdot r^*_{hi} \\right) \\cdot w_{hi}  λh=mh(1−fh)nh−1  \\lambda_h = \\sqrt{\\frac{m_h(1 - f_h)}{n_h - 1}}  : - whiw_{hi} design weight PSU ii stratum hh, wh=Nh/nhw_h = N_h / n_h average design weight entire stratum hh, - NhN_h total number units stratum hh, - nhn_h number PSUs original sample stratum hh, - rhi*∈{0,1,2,…}r^*_{hi} \\\\{0, 1, 2, \\dots\\} resampling indicator represents many times PSU ii stratum hh drawn bootstrap , - mh=nh−1m_h = n_h - 1 number units drawn replicate stratum hh, - λh\\lambda_h scaling factor used adjust weights bootstrap process, - fh=nh/Nhf_h = n_h / N_h sampling fraction stratum hh.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"use-of-rao-wu","dir":"Articles","previous_headings":"","what":"Use of Rao-Wu","title":"Rao-Wu Bootstrap in surveysd","text":"Rao-Wu bootstrap particularly suited complex survey designs stratification multi-stage selection. design-based variance estimation benefits resampling method accounts primary sampling stage incorporates finite population corrections (FPC) directly replicate weights. method appropriate sampling fraction first stage (.e., share selected PSUs within strata) relatively small, typically 10%. Rao-Wu suitable : - sampling fraction first stage large first-stage sampling without replacement. - survey include PSU-level identifiers, making first-stage resampling infeasible since method requires resampling entire PSUs reflect first-stage sampling variability. - design single-stage, methods like Preston bootstrap may appropriate. cases, recommended fall back alternative bootstrap methods default Preston approach implemented surveysd, offers flexibility wider range designs without PSU information.","code":""},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"single-psus","dir":"Articles","previous_headings":"","what":"Single PSUs","title":"Rao-Wu Bootstrap in surveysd","text":"dealing multistage sampling designs, issue single PSUs, e.g. single response unit stage stratum, can arise. applying resampling methods Rao-Wu bootstrap, single PSUs can introduce challenges resampling process. Rao-Wu method, adjust presence single PSUs combining next smallest stratum cluster applying resampling procedure. ensures resampling reflects structure original design maintaining appropriate variance estimates total statistics interest.","code":""},{"path":[]},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"load-dataset","dir":"Articles","previous_headings":"Example Implementation","what":"Load Dataset","title":"Rao-Wu Bootstrap in surveysd","text":"","code":"library(surveysd)  set.seed(1234) eusilc <- demo.eusilc(n = 2, prettyNames = TRUE)  eusilc[1:5, .(year, povertyRisk, gender, pWeight)]"},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"draw-bootstrap-replicates","dir":"Articles","previous_headings":"Example Implementation","what":"Draw bootstrap replicates","title":"Rao-Wu Bootstrap in surveysd","text":"bootstrap select ‘method = “Rao-Wu”’. Otherwise default “Preston” used.","code":"dat_boot_rw <- draw.bootstrap(eusilc,                                method = \"Rao-Wu\",                               REP = 10,                                hid = \"hid\",                                weights = \"pWeight\",                                strata = \"region\",                                period = \"year\")"},{"path":"https://statistikat.github.io/surveysd/articles/raowu.html","id":"calibrate-bootstrap-replicates","dir":"Articles","previous_headings":"Example Implementation","what":"Calibrate bootstrap replicates","title":"Rao-Wu Bootstrap in surveysd","text":"Calibrate sample according distribution gender (personal level) region (household level).","code":"dat_boot_calib <- recalib(dat_boot_rw,                            conP.var = \"gender\",                            conH.var = \"region\",                           epsP = 1e-2,                            epsH = 2.5e-2,                            verbose = FALSE) dat_boot_calib[1:5, .(year, povertyRisk, gender, pWeight, w1, w2, w3, w4)]"},{"path":"https://statistikat.github.io/surveysd/articles/surveysd.html","id":"load-dummy-data","dir":"Articles","previous_headings":"","what":"Load dummy data","title":"Introduction to surveysd","text":"test data set based data(eusilc, package = \"laeken\") can created demo.eusilc()","code":"library(surveysd)  set.seed(1234) eusilc <- demo.eusilc(n = 2, prettyNames = TRUE)  eusilc[1:5, .(year, povertyRisk, gender, pWeight)] ##     year povertyRisk gender  pWeight ##    <num>      <lgcl> <fctr>    <num> ## 1:  2010       FALSE female 504.5696 ## 2:  2010       FALSE   male 504.5696 ## 3:  2010       FALSE   male 504.5696 ## 4:  2010       FALSE female 493.3824 ## 5:  2010       FALSE   male 493.3824"},{"path":"https://statistikat.github.io/surveysd/articles/surveysd.html","id":"draw-bootstrap-replicates","dir":"Articles","previous_headings":"","what":"Draw bootstrap replicates","title":"Introduction to surveysd","text":"Use stratified resampling without replacement generate 10 samples. samples consistent respect reference periods.","code":"dat_boot <- draw.bootstrap(eusilc, REP = 10, hid = \"hid\", weights = \"pWeight\",                             strata = \"region\", period = \"year\")"},{"path":"https://statistikat.github.io/surveysd/articles/surveysd.html","id":"calibrate-bootstrap-replicates","dir":"Articles","previous_headings":"","what":"Calibrate bootstrap replicates","title":"Introduction to surveysd","text":"Calibrate sample according distribution gender (personal level) region (household level).","code":"dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\",                           epsP = 1e-2, epsH = 2.5e-2, verbose = FALSE) dat_boot_calib[1:5, .(year, povertyRisk, gender, pWeight, w1, w2, w3, w4)] ##     year povertyRisk gender  pWeight        w1       w2        w3          w4 ##    <num>      <lgcl> <fctr>    <num>     <num>    <num>     <num>       <num> ## 1:  2010       FALSE female 504.5696 0.4536267 999.4796 0.4595421   0.4486785 ## 2:  2010       FALSE   male 504.5696 0.4536267 999.4796 0.4595421   0.4486785 ## 3:  2010       FALSE   male 504.5696 0.4536267 999.4796 0.4595421   0.4486785 ## 4:  2010       FALSE female 493.3824 0.4429967 973.5124 0.4499649 986.3259754 ## 5:  2010       FALSE   male 493.3824 0.4429967 973.5124 0.4499649 986.3259754"},{"path":"https://statistikat.github.io/surveysd/articles/surveysd.html","id":"estimate-with-respect-to-a-grouping-variable","dir":"Articles","previous_headings":"","what":"Estimate with respect to a grouping variable","title":"Introduction to surveysd","text":"Estimate relative amount persons risk poverty per period gender. output contains estimates (val_povertyRisk) well standard errors (stE_povertyRisk) measured percent. rows gender = NA denotes aggregate genders corresponding year.","code":"err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio, group = \"gender\") err.est$Estimates ## Key: <year, n, N, gender, estimate_type> ##     year     n       N gender estimate_type val_povertyRisk stE_povertyRisk ##    <num> <int>   <num> <fctr>        <char>           <num>           <num> ## 1:  2010  7267 3979572   male        direct        12.02660       0.4024974 ## 2:  2010  7560 4202650 female        direct        16.73351       0.5150483 ## 3:  2010 14827 8182222   <NA>        direct        14.44422       0.3756081 ## 4:  2011  7267 3979572   male        direct        12.81921       0.5628467 ## 5:  2011  7560 4202650 female        direct        16.62488       0.4848524 ## 6:  2011 14827 8182222   <NA>        direct        14.77393       0.4230754"},{"path":"https://statistikat.github.io/surveysd/articles/surveysd.html","id":"estimate-with-respect-to-several-variables","dir":"Articles","previous_headings":"","what":"Estimate with respect to several variables","title":"Introduction to surveysd","text":"Estimate relative amount persons risk poverty per period region, gender, combination .","code":"group <- list(\"gender\", \"region\", c(\"gender\", \"region\")) err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio, group = group) head(err.est$Estimates) ## Key: <year, n, N, gender, region, estimate_type> ##     year     n        N gender     region estimate_type val_povertyRisk ##    <num> <int>    <num> <fctr>     <fctr>        <char>           <num> ## 1:  2010   261 122741.8   male Burgenland        direct       17.414524 ## 2:  2010   288 137822.2 female Burgenland        direct       21.432598 ## 3:  2010   359 182732.9   male Vorarlberg        direct       12.973259 ## 4:  2010   374 194622.1 female Vorarlberg        direct       19.883637 ## 5:  2010   440 253143.7   male   Salzburg        direct        9.156964 ## 6:  2010   484 282307.3 female   Salzburg        direct       17.939382 ##    stE_povertyRisk ##              <num> ## 1:        2.748313 ## 2:        3.018107 ## 3:        2.290904 ## 4:        2.637363 ## 5:        1.587959 ## 6:        1.224961 ## skipping 54 more rows"},{"path":"https://statistikat.github.io/surveysd/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Gussenbauer. Author, maintainer. Alexander Kowarik. Author. Eileen Vattheuer. Author. Gregor de Cillia. Author. Matthias Till. Contributor.","code":""},{"path":"https://statistikat.github.io/surveysd/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gussenbauer J, Kowarik , Vattheuer E, de Cillia G (2025). surveysd: Survey Standard Error Estimation Cumulated Estimates Differences Complex Panel Designs. R package version 2.0.1, https://github.com/statistikat/surveysd.","code":"@Manual{,   title = {surveysd: Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs},   author = {Johannes Gussenbauer and Alexander Kowarik and Eileen Vattheuer and Gregor {de Cillia}},   year = {2025},   note = {R package version 2.0.1},   url = {https://github.com/statistikat/surveysd}, }"},{"path":"https://statistikat.github.io/surveysd/index.html","id":"surveysd-","dir":"","previous_headings":"","what":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","title":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","text":"development place R-package surveysd. package can used estimate standard deviation estimates complex surveys using bootstrap weights.","code":""},{"path":"https://statistikat.github.io/surveysd/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","text":"","code":"# Install release version from CRAN install.packages(\"surveysd\")  # Install development version from GitHub devtools::install_github(\"statistikat/surveysd\")"},{"path":"https://statistikat.github.io/surveysd/index.html","id":"concept","dir":"","previous_headings":"","what":"Concept","title":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","text":"Bootstrapping long around used widely estimate confidence intervals standard errors point estimates. package aims combine necessary steps applying calibrated bootstrapping procedure custom estimating functions.","code":""},{"path":"https://statistikat.github.io/surveysd/index.html","id":"workflow","dir":"","previous_headings":"","what":"Workflow","title":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","text":"typical workflow package consists three steps. see concepts practice, please refer getting started vignette. Calibrated weights can generated function ipf() using iterative proportional updating algorithm. Bootstrap samples drawn rescaled bootstrapping function draw.bootstrap(). samples can calibrated iterative proportional updating algorithm using recalib(). Finally, estimation functions can applied bootstrap replicates calc.stError().","code":""},{"path":"https://statistikat.github.io/surveysd/index.html","id":"further-reading","dir":"","previous_headings":"","what":"Further reading","title":"Survey Standard Error Estimation for Cumulated Estimates and their Differences in Complex Panel Designs","text":"information can found github-pages site surveysd. methodology covered methodology vignette. comprehensive documentation calc.stError() available error estimation vignette.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighted Point Estimates — PointEstimates","title":"Weighted Point Estimates — PointEstimates","text":"Predefined functions weighted point estimates package surveysd.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weighted Point Estimates — PointEstimates","text":"","code":"weightedRatio(x, w)  weightedSum(x, w)"},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weighted Point Estimates — PointEstimates","text":"x numeric vector w weight vector","code":""},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weighted Point Estimates — PointEstimates","text":"functions return single numeric value","code":""},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weighted Point Estimates — PointEstimates","text":"Predefined functions weighted ratio weighted sum.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/PointEstimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weighted Point Estimates — PointEstimates","text":"","code":"x <- 1:10 w <- 10:1 weightedRatio(x,w) #> [1] 18.18182 x <- 1:10 w <- 10:1 weightedSum(x,w) #> [1] 220"},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"Calculate point estimates well standard errors variables surveys. Standard errors estimated using bootstrap weights (see draw.bootstrap recalib). addition standard error estimate can calcualted using survey data 3 consecutive periods, results reduction standard error.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"","code":"calc.stError(   dat,   weights = attr(dat, \"weights\"),   b.weights = attr(dat, \"b.rep\"),   period = attr(dat, \"period\"),   var = NULL,   fun = weightedRatio,   relative.share = FALSE,   group = NULL,   group.diff = FALSE,   fun.adjust.var = NULL,   adjust.var = NULL,   period.diff = NULL,   period.mean = NULL,   bias = FALSE,   size.limit = 20,   cv.limit = 10,   p = NULL,   add.arg = NULL,   national = FALSE )"},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"dat either data.frame data.table containing survey data. Surveys can panel survey rotating panel survey, need . rotating panel survey bootstrap weights can created using draw.bootstrap recalib. weights character specifying name column dat containing original sample weights. Used calculate point estimates. b.weights character vector specifying names columns dat containing bootstrap weights. Used calculate standard errors. period character specifying name column dat containing sample periods. var character vector containing variable names dat fun shall applied sample period. var = NULL results reflect sum weights. fun function applied var sample period. Predefined functions weightedRatio, weightedSum, can also take function returns double integer uses weights second argument. relative.share boolean, TRUE point estimates resulting fun divided point estimate population level per period. group character vectors list character vectors containig variables dat. list entry dat split subgroups according containing variables well period. pointestimates estimated subgroup seperately. group=NULL data split sample periods default. group.diff boolen, TRUE differences standard error groups defined group calculated. See details explanations. fun.adjust.var can either NULL function. argument can used apply function period bootstrap weight data. resulting estimates passed fun. See details explanations. adjust.var can either NULL character specifying first argument fun.adjust.var. period.diff character vectors, defining periods differences point estimate well standard error calculated. entry must form \"period1 - period2\". Can NULL period.mean odd integer, defining range periods sample mean point estimates additionally calcualted. bias boolean, TRUE sample mean point estimates bootstrap weights returned. size.limit integer defining lower bound number observations dat group defined period entries group. Warnings returned number observations subgroup falls size.limit. addition concerned groups available function output. cv.limit non-negativ value defining upper bound standard error relation point estimate. relation exceed cv.limit, point estimate, flagged available function output. p numeric vector containing values 0 1. Defines quantiles distribution var additionally estimated. add.arg additional arguments passed fun. Can either named list vector. names object correspond function arguments values column names dat, see also examples. national DEPRECATED use relative.share instead! boolean, TRUE point estimates resulting fun divided point estimate national level.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"Returns list containing: Estimates: data.table containing period differences /k period averages estimates fun applied var well corresponding standard errors, calculated using bootstrap weights. addition sample size, n, poplutaion size group added output. smallGroups: data.table containing groups number observation falls size.limit. cvHigh: data.table containing boolean variable indicates estimate estimated standard error exceeds cv.limit. stEDecrease: data.table indicating estimate theoretical increase sample size gained averaging k periods. returned period.mean NULL.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"calc.stError takes survey data (dat) returns point estimates well standard Errors defined fun var sample period dat. dat must household data household members correspond multiple rows household identifier. data least contain following columns: Column indicating sample period; Column indicating household ID; Column containing household sample weights; Columns contain bootstrap weights (see output recalib); Columns listed var well group variable var well sample period function fun applied using original well bootstrap sample weights. point estimate selected result fun using original sample weights standard error estimated result fun using bootstrap sample weights. fun can function returns double integer uses sample weights second argument. predifined options weightedRatio weightedSum. option weightedRatio weighted ratio (\\ calculated var equal 1, e.g sum(weight[var==1])/sum(weight[!.na(var)])*100. Additionally using option national=TRUE weighted ratio (\\ divided weighted ratio national level period.  group NULL vector variables dat fun applied subset dat defined combinations values group. instance group = \"sex\" \"sex\" values \"Male\" \"Female\" dat point estimate standard error calculated subsets dat \"Male\" \"Female\" value \"sex\". done value period. variables group NAs dat rows containing missings discarded.  group list character vectors, subsets dat following estimation point estimate, including estimate standard error, calculated list entry. group.diff = TRUE difference groups definded group calculated. Differences calculated within variables group, e.g group = c(\"gender\", \"region\") calcualate estimates group also differences within \"gender\" \"region\" seperately. grouping done multiple variables e.g group = list(c(\"gender\",\"region\")) (~ grouping \"gender\" x \"region\") differences calculated groups one grouping variables different. instance difference gender = \"female\" & region = \"Vienna\" gender = \"male\" & region = \"Vienna\" gender = \"female\" & region = \"Vienna\" gender = \"female\" & region = \"Salzburg\" calculated. difference gender = \"female\" & region = \"Vienna\" gender = \"male\" & region = \"Salzburg\" calculated. order difference determined order value (alpha-numerical order) grouping contains factor variables factor levels determin order.  optional parameters fun.adjust.var adjust.var can used values var dependent weights. instance case poverty thershhold calculated EU-SILC. case additional function can supplied using fun.adjust.var well first argument adjust.var, needs part data set dat. , applying fun variable var period groups, function fun.adjust.var applied adjust.var using bootstrap weights seperately (NOTE: weight used second argument fun.adjust.var). Thus creating =1,...,length(b.weights) additional variables. applying fun var estimates bootstrap replicate now use corresponding new additional variables. instead $$fun(var,weights,...),fun(var,b.weights[1],...), fun(var,b.weights[2],...),...$$ function fun applied way $$fun(var,weights,...),fun(var.1,b.weights[1],...),fun(var.2, b.weights[2],...),...$$ var.1, var.2, ... correspond estimates resulting fun.adjust.var adjust.var. NOTE: procedure especially usefull var dependent weights fun applied subgroups data set. possible capture procedure fun var, see examples hands explanation.  defining period.diff difference point estimates periods well standard errors calculated. entries period.diff must form \"period1 - period2\" means results point estimates period2 substracted results point estimates period1. Specifying period.mean leads improvement standard error averaging results point estimates, using bootstrap weights, period.mean periods. Setting, instance, period.mean = 3 results averaging results consecutive set 3 periods. Estimating standard error averages gives improved estimate standard error central period, used averaging. averaging results also applied differences point estimates. instance defining period.diff = \"2015-2009\" period.mean = 3 differences point estimates 2015 2009, 2016 2010 well 2014 2008 calcualated finally average 3 differences calculated. periods set period.diff always used middle periods around mean period.mean years build.  Setting bias TRUE returns calculation mean results bootstrap replicates.  output corresponding columns labeled _mean end. fun needs arguments can supplied add.arg. can either named list vector. parameter size.limit indicates lower bound sample size subsets dat created group. sample size subset falls size.limit warning displayed. addition subsets case can selected output calc.stError $smallGroups. parameter cv.limit one can set upper bound coefficient variantion. Estimates exceed bound flagged TRUE available function output $cvHigh. cv.limit must positive integer treated internally \\ cv.limit=1 estimate flagged coefficient variantion exceeds 1\\  specifying period.mean, decrease standard error choosing method internally calcualted rough estimate implied increase sample size available output $stEDecrease. rough estimate increase sample size uses fact sample size \\(n\\) sample estimate standard error point estimates converges factor \\(1/\\sqrt{n}\\) true standard error \\(\\sigma\\).","code":""},{"path":[]},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"Johannes Gussenbauer, Alexander Kowarik, Statistics Austria","code":""},{"path":"https://statistikat.github.io/surveysd/reference/calc.stError.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calcualte point estimates and their standard errors using bootstrap weights. — calc.stError","text":"","code":"# Import data and calibrate  library(surveysd) library(data.table) setDTthreads(1) set.seed(1234) eusilc <- demo.eusilc(n = 4,prettyNames = TRUE) dat_boot <- draw.bootstrap(eusilc, REP = 3, hid = \"hid\", weights = \"pWeight\",                            strata = \"region\", period = \"year\") dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\") #> Iteration stopped after 3 steps #> Convergence reached #> Iteration stopped after 1 steps #> Convergence reached #> Iteration stopped after 2 steps #> Convergence reached  # estimate weightedRatio for povertyRisk per period  err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\",                         fun = weightedRatio) err.est$Estimates #> Key: <year, n, N, estimate_type> #>     year     n       N estimate_type val_povertyRisk stE_povertyRisk #>    <num> <int>   <num>        <char>           <num>           <num> #> 1:  2010 14827 8182222        direct        14.44422       0.1950220 #> 2:  2011 14827 8182222        direct        14.77393       0.6025234 #> 3:  2012 14827 8182222        direct        15.04515       0.3617479 #> 4:  2013 14827 8182222        direct        14.89013       0.3629747  # calculate weightedRatio for povertyRisk and fraction of one-person # households per period  dat_boot_calib[, onePerson := .N == 1, by = .(year, hid)] #>          hid  hsize        region     pid       age gender   ecoStat #>        <int> <fctr>        <fctr>   <int>    <fctr> <fctr>    <fctr> #>     1:     1      3         Tyrol     101   (25,45] female part time #>     2:     1      3         Tyrol     102   (25,45]   male full time #>     3:     1      3         Tyrol     103 (-Inf,16]   male      <NA> #>     4:     2      4         Tyrol     201   (25,45] female  domestic #>     5:     2      4         Tyrol     202   (25,45]   male full time #>    ---                                                               #> 59304:  8999      4 Lower Austria  899904 (-Inf,16] female education #> 59305: 10500      1 Upper Austria 1050001   (25,45] female full time #> 59306:  5999      1         Tyrol  599901   (25,45]   male full time #> 59307:  7500      2         Tyrol  750001   (45,65]   male full time #> 59308:  7500      2         Tyrol  750002   (45,65] female  disabled #>        citizenship   py010n py050n  py090n py100n py110n py120n py130n py140n #>             <fctr>    <num>  <num>   <num>  <num>  <num>  <num>  <num>  <num> #>     1:          AT  9756.25      0    0.00      0      0      0      0      0 #>     2:       Other 12471.60      0    0.00      0      0      0      0      0 #>     3:        <NA>       NA     NA      NA     NA     NA     NA     NA     NA #>     4:          AT 12487.03      0    0.00      0      0      0      0      0 #>     5:          AT 42821.23      0    0.00      0      0      0      0      0 #>    ---                                                                        #> 59304:          AT     0.00      0    0.00      0      0      0      0      0 #> 59305:          AT 13962.56      0    0.00      0      0      0      0      0 #> 59306:          AT 14685.18      0    0.00      0      0      0      0      0 #> 59307:          AT 20606.82      0    0.00      0      0      0      0      0 #> 59308:          AT     0.00      0 3825.63      0      0      0      0      0 #>        hy040n  hy050n hy070n hy080n hy090n hy110n hy130n hy145n  eqSS  eqIncome #>         <num>   <num>  <num>  <num>  <num>  <num>  <num>  <num> <num>     <num> #>     1: 4273.9 2428.11      0      0  33.39      0      0      0   1.8 16090.694 #>     2: 4273.9 2428.11      0      0  33.39      0      0      0   1.8 16090.694 #>     3: 4273.9 2428.11      0      0  33.39      0      0      0   1.8 16090.694 #>     4:    0.0 1549.72      0      0   2.13      0      0      0   2.1 27076.243 #>     5:    0.0 1549.72      0      0   2.13      0      0      0   2.1 27076.243 #>    ---                                                                          #> 59304:    0.0 1955.19      0      0   0.00      0      0      0   2.5 26970.023 #> 59305:    0.0    0.00      0      0 424.85      0      0      0   1.0  6923.625 #> 59306:    0.0    0.00      0      0 120.65      0      0      0   1.0 14805.830 #> 59307:    0.0    0.00      0      0   0.00      0      0      0   1.5 24680.877 #> 59308:    0.0    0.00      0      0   0.00      0      0      0   1.5 24680.877 #>           db090  pWeight  year povertyRisk           w1           w2 #>           <num>    <num> <num>      <lgcl>        <num>        <num> #>     1: 504.5696 504.5696  2010       FALSE  986.1108671    0.4486785 #>     2: 504.5696 504.5696  2010       FALSE  986.1108671    0.4486785 #>     3: 504.5696 504.5696  2010       FALSE  986.1108671    0.4486785 #>     4: 493.3824 493.3824  2010       FALSE  961.8474239  986.3259754 #>     5: 493.3824 493.3824  2010       FALSE  961.8474239  986.3259754 #>    ---                                                               #> 59304: 556.4260 556.4260  2013       FALSE 1112.7047546    0.9776065 #> 59305: 643.2557 643.2557  2013        TRUE    0.6003829 1285.9053590 #> 59306: 679.7288 679.7288  2013       FALSE 1339.9471879    0.6044353 #> 59307: 567.1544 567.1544  2013       FALSE 1115.6949561 1133.8043941 #> 59308: 567.1544 567.1544  2013       FALSE 1115.6949561 1133.8043941 #>                  w3 onePerson #>               <num>    <lgcl> #>     1:    0.4478475     FALSE #>     2:    0.4478475     FALSE #>     3:    0.4478475     FALSE #>     4:  984.4165669     FALSE #>     5:  984.4165669     FALSE #>    ---                        #> 59304:    0.9654150     FALSE #> 59305: 1274.0021691      TRUE #> 59306:    0.5949548      TRUE #> 59307:    0.4980413     FALSE #> 59308:    0.4980413     FALSE err.est <- calc.stError(dat_boot_calib, var = c(\"povertyRisk\", \"onePerson\"),                         fun = weightedRatio) err.est$Estimates #> Key: <year, n, N, estimate_type> #>     year     n       N estimate_type val_povertyRisk stE_povertyRisk #>    <num> <int>   <num>        <char>           <num>           <num> #> 1:  2010 14827 8182222        direct        14.44422       0.3912507 #> 2:  2011 14827 8182222        direct        14.77393       0.4093996 #> 3:  2012 14827 8182222        direct        15.04515       0.3271038 #> 4:  2013 14827 8182222        direct        14.89013       0.2955243 #>    val_onePerson stE_onePerson #>            <num>         <num> #> 1:      14.85737     0.3912507 #> 2:      14.85737     0.4093996 #> 3:      14.85737     0.3271038 #> 4:      14.85737     0.2955243   # estimate weightedRatio for povertyRisk per period and gender and # period x region x gender   group <- list(\"gender\", c(\"gender\", \"region\")) err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\",                         fun = weightedRatio, group = group) err.est$Estimates #> Key: <year, n, N, gender, region, estimate_type> #>      year     n         N gender        region estimate_type val_povertyRisk #>     <num> <int>     <num> <fctr>        <fctr>        <char>           <num> #>  1:  2010   261  122741.8   male    Burgenland        direct       17.414524 #>  2:  2010   288  137822.2 female    Burgenland        direct       21.432598 #>  3:  2010   359  182732.9   male    Vorarlberg        direct       12.973259 #>  4:  2010   374  194622.1 female    Vorarlberg        direct       19.883637 #>  5:  2010   440  253143.7   male      Salzburg        direct        9.156964 #>  6:  2010   484  282307.3 female      Salzburg        direct       17.939382 #>  7:  2010   517  268581.4   male     Carinthia        direct       10.552149 #>  8:  2010   561  295066.6 female     Carinthia        direct       15.392924 #>  9:  2010   650  339566.5   male         Tyrol        direct       12.857542 #> 10:  2010   667  362332.5 female         Tyrol        direct       17.604861 #> 11:  2010  1128  571011.7   male        Styria        direct       11.671247 #> 12:  2010  1132  774405.4   male        Vienna        direct       15.590616 #> 13:  2010  1167  596033.3 female        Styria        direct       16.964539 #> 14:  2010  1190  824525.6 female        Vienna        direct       18.778813 #> 15:  2010  1363  684272.5   male Upper Austria        direct        9.074690 #> 16:  2010  1387  772593.2 female Lower Austria        direct       16.372949 #> 17:  2010  1417  783115.8   male Lower Austria        direct       11.348283 #> 18:  2010  1442  737347.5 female Upper Austria        direct       12.574206 #> 19:  2010  7267 3979571.7   male          <NA>        direct       12.026600 #> 20:  2010  7560 4202650.3 female          <NA>        direct       16.733508 #> 21:  2010 14827 8182222.0   <NA>          <NA>        direct       14.444218 #> 22:  2011   261  122741.8   male    Burgenland        direct       16.465679 #> 23:  2011   288  137822.2 female    Burgenland        direct       21.245704 #> 24:  2011   359  182732.9   male    Vorarlberg        direct       12.590109 #> 25:  2011   374  194622.1 female    Vorarlberg        direct       17.125259 #> 26:  2011   440  253143.7   male      Salzburg        direct       11.189644 #> 27:  2011   484  282307.3 female      Salzburg        direct       18.213248 #> 28:  2011   517  268581.4   male     Carinthia        direct       12.789630 #> 29:  2011   561  295066.6 female     Carinthia        direct       16.745958 #> 30:  2011   650  339566.5   male         Tyrol        direct       12.531181 #> 31:  2011   667  362332.5 female         Tyrol        direct       16.522466 #> 32:  2011  1128  571011.7   male        Styria        direct       10.163611 #> 33:  2011  1132  774405.4   male        Vienna        direct       16.616484 #> 34:  2011  1167  596033.3 female        Styria        direct       15.322461 #> 35:  2011  1190  824525.6 female        Vienna        direct       18.582643 #> 36:  2011  1363  684272.5   male Upper Austria        direct       11.360200 #> 37:  2011  1387  772593.2 female Lower Austria        direct       16.109340 #> 38:  2011  1417  783115.8   male Lower Austria        direct       12.419104 #> 39:  2011  1442  737347.5 female Upper Austria        direct       14.426605 #> 40:  2011  7267 3979571.7   male          <NA>        direct       12.819212 #> 41:  2011  7560 4202650.3 female          <NA>        direct       16.624882 #> 42:  2011 14827 8182222.0   <NA>          <NA>        direct       14.773925 #> 43:  2012   261  122741.8   male    Burgenland        direct       16.005251 #> 44:  2012   288  137822.2 female    Burgenland        direct       19.646025 #> 45:  2012   359  182732.9   male    Vorarlberg        direct       12.650134 #> 46:  2012   374  194622.1 female    Vorarlberg        direct       16.089942 #> 47:  2012   440  253143.7   male      Salzburg        direct       11.305057 #> 48:  2012   484  282307.3 female      Salzburg        direct       18.150559 #> 49:  2012   517  268581.4   male     Carinthia        direct       14.157852 #> 50:  2012   561  295066.6 female     Carinthia        direct       15.926182 #> 51:  2012   650  339566.5   male         Tyrol        direct       15.104689 #> 52:  2012   667  362332.5 female         Tyrol        direct       17.449297 #> 53:  2012  1128  571011.7   male        Styria        direct       11.019424 #> 54:  2012  1132  774405.4   male        Vienna        direct       16.099733 #> 55:  2012  1167  596033.3 female        Styria        direct       13.902894 #> 56:  2012  1190  824525.6 female        Vienna        direct       16.796126 #> 57:  2012  1363  684272.5   male Upper Austria        direct       13.557275 #> 58:  2012  1387  772593.2 female Lower Austria        direct       16.563011 #> 59:  2012  1417  783115.8   male Lower Austria        direct       13.606128 #> 60:  2012  1442  737347.5 female Upper Austria        direct       15.494037 #> 61:  2012  7267 3979571.7   male          <NA>        direct       13.760647 #> 62:  2012  7560 4202650.3 female          <NA>        direct       16.261469 #> 63:  2012 14827 8182222.0   <NA>          <NA>        direct       15.045149 #> 64:  2013   261  122741.8   male    Burgenland        direct       20.636575 #> 65:  2013   288  137822.2 female    Burgenland        direct       21.223485 #> 66:  2013   359  182732.9   male    Vorarlberg        direct       12.311667 #> 67:  2013   374  194622.1 female    Vorarlberg        direct       15.716327 #> 68:  2013   440  253143.7   male      Salzburg        direct       11.427862 #> 69:  2013   484  282307.3 female      Salzburg        direct       17.234804 #> 70:  2013   517  268581.4   male     Carinthia        direct       12.594461 #> 71:  2013   561  295066.6 female     Carinthia        direct       13.368498 #> 72:  2013   650  339566.5   male         Tyrol        direct       14.564544 #> 73:  2013   667  362332.5 female         Tyrol        direct       16.559763 #> 74:  2013  1128  571011.7   male        Styria        direct       11.942973 #> 75:  2013  1132  774405.4   male        Vienna        direct       16.144697 #> 76:  2013  1167  596033.3 female        Styria        direct       14.377224 #> 77:  2013  1190  824525.6 female        Vienna        direct       17.419665 #> 78:  2013  1363  684272.5   male Upper Austria        direct       13.461762 #> 79:  2013  1387  772593.2 female Lower Austria        direct       14.978617 #> 80:  2013  1417  783115.8   male Lower Austria        direct       13.710926 #> 81:  2013  1442  737347.5 female Upper Austria        direct       15.272207 #> 82:  2013  7267 3979571.7   male          <NA>        direct       13.889623 #> 83:  2013  7560 4202650.3 female          <NA>        direct       15.837536 #> 84:  2013 14827 8182222.0   <NA>          <NA>        direct       14.890134 #>      year     n         N gender        region estimate_type val_povertyRisk #>     stE_povertyRisk #>               <num> #>  1:       0.1884171 #>  2:       2.1221766 #>  3:       3.8616769 #>  4:       6.4453100 #>  5:       0.8465838 #>  6:       0.9294272 #>  7:       0.8545573 #>  8:       1.4023756 #>  9:       1.2288300 #> 10:       3.4130337 #> 11:       1.2348645 #> 12:       0.5215247 #> 13:       0.8873138 #> 14:       0.9946205 #> 15:       1.1994510 #> 16:       1.1764679 #> 17:       1.2369329 #> 18:       1.0034896 #> 19:       0.2165269 #> 20:       0.2651936 #> 21:       0.1950220 #> 22:       1.7222000 #> 23:       3.5606645 #> 24:       1.1983197 #> 25:       5.3854576 #> 26:       1.3068652 #> 27:       2.7699010 #> 28:       2.4268991 #> 29:       3.0728432 #> 30:       1.7243884 #> 31:       3.4614659 #> 32:       1.4342542 #> 33:       1.2527233 #> 34:       1.6011776 #> 35:       1.0001555 #> 36:       0.8967023 #> 37:       1.7547411 #> 38:       0.9014444 #> 39:       0.8505126 #> 40:       0.5590423 #> 41:       0.7109536 #> 42:       0.6025234 #> 43:       1.9324379 #> 44:       2.3749151 #> 45:       1.8415722 #> 46:       4.7531788 #> 47:       0.7045088 #> 48:       1.2085025 #> 49:       2.0103522 #> 50:       2.0344424 #> 51:       1.1465549 #> 52:       2.5376933 #> 53:       0.4468153 #> 54:       0.5477246 #> 55:       0.3113131 #> 56:       0.5794666 #> 57:       1.5135587 #> 58:       0.7981621 #> 59:       1.5057314 #> 60:       1.5140923 #> 61:       0.6341754 #> 62:       0.1733140 #> 63:       0.3617479 #> 64:       2.9129187 #> 65:       2.8428517 #> 66:       2.0548705 #> 67:       3.3928661 #> 68:       1.5814004 #> 69:       1.3588826 #> 70:       0.9889204 #> 71:       2.7859091 #> 72:       1.5740531 #> 73:       2.0348684 #> 74:       1.1846937 #> 75:       1.7795913 #> 76:       0.5236336 #> 77:       1.9264693 #> 78:       0.8359434 #> 79:       1.0664597 #> 80:       1.8688574 #> 81:       0.7269972 #> 82:       0.3617954 #> 83:       0.4285095 #> 84:       0.3629747 #>     stE_povertyRisk  # use average over 3 periods for standard error estimation # and calculate estimate for difference of # period 2011 and 2012 inclulding standard errors period.diff <- c(\"2012-2011\") err.est <- calc.stError(   dat_boot_calib, var = \"povertyRisk\", fun = weightedRatio,   period.diff = period.diff,  # <- take difference of periods 2012 and 2011   period.mean = 3)  # <- average over 3 periods err.est$Estimates #> Key: <year, n, N, estimate_type> #>              year     n       N                      estimate_type #>            <char> <num>   <num>                             <char> #> 1:           2010 14827 8182222                             direct #> 2: 2010_2011_2012 14827 8182222                     period average #> 3:           2011 14827 8182222                             direct #> 4: 2011_2012_2013 14827 8182222                     period average #> 5:           2012 14827 8182222                             direct #> 6:      2012-2011 14827 8182222                  period difference #> 7: 2012-2011_mean 14827 8182222 difference between period averages #> 8:           2013 14827 8182222                             direct #>    val_povertyRisk stE_povertyRisk #>              <num>           <num> #> 1:      14.4442182      0.19502204 #> 2:      14.7544308      0.30015639 #> 3:      14.7739255      0.60252339 #> 4:      14.9030692      0.33633985 #> 5:      15.0451487      0.36174795 #> 6:       0.2712233      0.68918100 #> 7:       0.1486385      0.06591599 #> 8:      14.8901335      0.36297469  # for more examples see https://statistikat.github.io/surveysd/articles/error_estimation.html"},{"path":"https://statistikat.github.io/surveysd/reference/computeFrac.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical weighting functions — computeLinear","title":"Numerical weighting functions — computeLinear","text":"Customize weight-updating within factor levels case numerical calibration. functions described serve inputs ipf.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/computeFrac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical weighting functions — computeLinear","text":"","code":"computeLinear(curValue, target, x, w, boundLinear = 10)  computeLinearG1_old(curValue, target, x, w, boundLinear = 10)  computeLinearG1(curValue, target, x, w, boundLinear = 10)  computeFrac(curValue, target, x, w)"},{"path":"https://statistikat.github.io/surveysd/reference/computeFrac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical weighting functions — computeLinear","text":"curValue Current summed value. sum(x*w) target Target value. element conP ipf x Vector numeric values calibrated w Vector weights boundLinear output f satisfy 1/boundLinear <= f <= boundLinear. See bound ipf","code":""},{"path":"https://statistikat.github.io/surveysd/reference/computeFrac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerical weighting functions — computeLinear","text":"weight multiplier f","code":""},{"path":"https://statistikat.github.io/surveysd/reference/computeFrac.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Numerical weighting functions — computeLinear","text":"computeFrac provides \"standard\" IPU updating scheme given $$f = target/curValue$$ means weight inside level multtiplied factor actual update step (w := f*w). computeLinear hand calculates f  b chosen, f satisfies following two equations.  computeLinearG1 calculates f way computeLinear, f_i*w_i<1 f_i set 1/w_i.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/cpp_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate mean by factors — cpp_mean","title":"Calculate mean by factors — cpp_mean","text":"functions calculate arithmetic geometric mean weight class. geometric_mean arithmetic_mean return numeric vector length w stores averaged weight observation. geometric_mean_reference returns value reference, .e. input value w gets overwritten updated weights. See examples.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/cpp_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate mean by factors — cpp_mean","text":"","code":"geometric_mean_reference(w, classes)"},{"path":"https://statistikat.github.io/surveysd/reference/cpp_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate mean by factors — cpp_mean","text":"w numeric vector. entries positive. classes factor variable. Must length w.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/cpp_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate mean by factors — cpp_mean","text":"","code":"if (FALSE) { # \\dontrun{  ## create random data nobs <- 10 classLabels <- letters[1:3] dat = data.frame(   weight = exp(rnorm(nobs)),   household = factor(sample(classLabels, nobs, replace = TRUE)) ) dat  ## calculate weights with geometric_mean geom_weight <- geometric_mean(dat$weight, dat$household) cbind(dat, geom_weight)  ## calculate weights with arithmetic_mean arith_weight <- arithmetic_mean(dat$weight, dat$household) cbind(dat, arith_weight)  ## calculate weights \"by reference\" geometric_mean_reference(dat$weight, dat$household) dat } # }"},{"path":"https://statistikat.github.io/surveysd/reference/demo.eusilc.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate multiple years of EU-SILC data — demo.eusilc","title":"Generate multiple years of EU-SILC data — demo.eusilc","text":"Create dummy dataset used demonstrating functionalities surveysd package based laeken::eusilc. Please refer documentation page original data details variables.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/demo.eusilc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate multiple years of EU-SILC data — demo.eusilc","text":"","code":"demo.eusilc(n = 8, prettyNames = FALSE)"},{"path":"https://statistikat.github.io/surveysd/reference/demo.eusilc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate multiple years of EU-SILC data — demo.eusilc","text":"n Number years generate. least 1 prettyNames Create easy--read names certain variables. Recommended demonstration purposes. Otherwise, use original codes documented laeken::eusilc.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/demo.eusilc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate multiple years of EU-SILC data — demo.eusilc","text":"prettyNames TRUE, following variables available easy--read manner. hid Household id. Consistent respect reference period (year) hsize Size household. derived hid period region Federal state austria household located pid Personal id. Consistent respect reference period (year) age Age-class respondent gender persons gender (\"male\", \"Female\") ecoStat Ecnomic status (\"part time\", \"full time\", \"unemployed\", ...) citizenship Citizenship (\"\", \"EU\", \"\") pWeight Personal sample weight inside reference period year. Simulated reference period povertyRisk. Logical variable determining whether respondent risk poverty","code":""},{"path":"https://statistikat.github.io/surveysd/reference/demo.eusilc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate multiple years of EU-SILC data — demo.eusilc","text":"","code":"demo.eusilc(n = 1, prettyNames = TRUE)[, c(1:8, 26, 28:30)] #>          hid  hsize        region    pid       age gender   ecoStat citizenship #>        <int> <fctr>        <fctr>  <int>    <fctr> <fctr>    <fctr>      <fctr> #>     1:     1      3         Tyrol    101   (25,45] female part time          AT #>     2:     1      3         Tyrol    102   (25,45]   male full time       Other #>     3:     1      3         Tyrol    103 (-Inf,16]   male      <NA>        <NA> #>     4:     2      4         Tyrol    201   (25,45] female  domestic          AT #>     5:     2      4         Tyrol    202   (25,45]   male full time          AT #>    ---                                                                          #> 14823:  5997      4 Lower Austria 599704 (-Inf,16] female education          AT #> 14824:  5998      1 Upper Austria 599801   (25,45] female full time          AT #> 14825:  5999      1         Tyrol 599901   (25,45]   male full time          AT #> 14826:  6000      2         Tyrol 600001   (45,65]   male full time          AT #> 14827:  6000      2         Tyrol 600002   (45,65] female  disabled          AT #>        eqIncome  pWeight  year povertyRisk #>           <num>    <num> <num>      <lgcl> #>     1: 16090.69 504.5696  2010       FALSE #>     2: 16090.69 504.5696  2010       FALSE #>     3: 16090.69 504.5696  2010       FALSE #>     4: 27076.24 493.3824  2010       FALSE #>     5: 27076.24 493.3824  2010       FALSE #>    ---                                     #> 14823: 26508.20 556.4260  2010       FALSE #> 14824: 14387.41 643.2557  2010       FALSE #> 14825: 14805.83 679.7288  2010       FALSE #> 14826: 16288.30 567.1544  2010       FALSE #> 14827: 16288.30 567.1544  2010       FALSE"},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw bootstrap replicates — draw.bootstrap","title":"Draw bootstrap replicates — draw.bootstrap","text":"Draw bootstrap replicates survey data rotating panel design. Survey information, like ID, sample weights, strata population totals per strata, specified ensure meaningfull survey bootstraping.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw bootstrap replicates — draw.bootstrap","text":"","code":"draw.bootstrap(   dat,   method = \"Preston\",   REP = 1000,   hid = NULL,   weights,   period = NULL,   strata = NULL,   cluster = NULL,   totals = NULL,   single.PSU = c(\"merge\", \"mean\"),   boot.names = NULL,   split = FALSE,   pid = NULL,   seed = NULL,   already.selected = NULL )"},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw bootstrap replicates — draw.bootstrap","text":"dat either data.frame data.table containing survey data rotating panel design. method bootstrap replicates, either \"Preston\" \"Rao-Wu\" REP integer indicating number bootstrap replicates. hid character specifying name column dat containing household id. NULL (default), household structure regarded. weights character specifying name column dat containing sample weights. period character specifying name column dat containing sample periods. NULL (default), assumed observations belong period. strata character vector specifying name(s) column dat population stratified. strata vector stratification assumed combination column names contained strata. Setting addition cluster NULL stratification assumed multiple stages, additional entry strata specifies stratification variable next lower stage. see Details information. cluster character vector specifying cluster data. already specified cluster household ID taken es lowest level cluster. totals character specifying name column dat containing totals per strata /cluster. optional cluster NULL equal hid strata contains one columnname! households per strata calcualted using weights argument. clusters strata multiple stages specified totals needs vector length(strata) specifying column dat contain total number PSUs stage. totals interpreted left right, meaning first argument corresponds number PSUs first last argument number PSUs last stage. single.PSU either \"merge\" \"mean\" defining single PSUs need dealt . single.PSU=\"merge\" single PSUs stage merged strata cluster next least number PSUs. multiple exist one select via random draw. single.PSU=\"mean\" single PSUs get mean bootstrap replicates stage contain single PSUs. boot.names character indicating leading string column names bootstrap replica. NULL defaults \"w\". split logical, TRUE split households considered using pid, information see Details. pid column dat specifying personal identifier. identifier needs unique person throught whole data set. Can NULL. seed integer specifying seed random number generator. already.selected list data.tables indicating record drawn previous period. length(already.selected) must equal number sampling stages specified. See get.selection() example.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw bootstrap replicates — draw.bootstrap","text":"survey data number REP bootstrap replicates added columns. Returns data.table containing original data well number REP columns containing bootstrap replicates repetition. columns bootstrap replicates default labeled \"wNumber\" Number goes 1 REP. column names bootstrap replicates start different character string parameter boot.names can used.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw bootstrap replicates — draw.bootstrap","text":"draw.bootstrap takes dat draws REP bootstrap replicates . dat must household data household members correspond multiple rows household identifier. practical applications, following columns available dataset passed via corresponding parameters: Column indicating sample period (parameter period). Column indicating household ID (parameter hid) Column containing household sample weights (parameter weights); Columns population stratified sampling process (parameter: strata). methods either either rescaled bootstrap stratified multistage sampling, presented J. Preston (2009) (method = \"Preston\") Rao-Wu boostrap J. N. K. Rao C. F. J. Wu (1988) (method = \"Rao-Wu\") supported.  single stage sampling design column argument totals optional, meaning column number PSUs first stage need supplied. number PSUs calculated added dat using strata weights. setting cluster NULL single stage sampling design always assumed strata contains multiple column names combination column names used stratification.  case multi stage sampling design argument totals needs specified needs number arguments strata.  cluster NULL contain hid last stage, hid automatically used final cluster. , besides hid, clustering additional stages specified number column names strata cluster (including hid) must . stage clustering stratification one can set \"1\" \"\" stage.  example strata=c(\"REGION\",\"\"),cluster=c(\"MUNICIPALITY\",\"HID\") speficy 2 stage sampling design first stage municipalities drawn stratified regions 2nd stage housholds drawn municipality without stratification.  Bootstrap replicates drawn survey period consecutively (period) using function rescaled.bootstrap. Bootstrap replicates drawn consistently way period sampling stage always \\(\\lfloor n/2 \\rfloor\\) clusters selected strata.  ensures bootstrap replicates follow logic sampled households, making bootstrap replicates comparable actual sample units.  split ist set TRUE pid specified, bootstrap replicates carried forward using personal identifiers instead household identifier. takes account issue houshold splitting . person new split household get bootstrap replicate person come household survey. People enter already existing households also get bootstrap replicate households members previous periods. already.selected can specified order construct bootstrap replicates considering already drawn bootstrap replicates previous period exist survey. See get.selection() explanations examples.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Draw bootstrap replicates — draw.bootstrap","text":"Preston, J. (2009). Rescaled bootstrap stratified multistage sampling. Survey Methodology. 35. 227-234. Rao, J. N. K., C. F. J. Wu. (1988). Resampling Inference Complex Survey Data. Journal American Statistical Association 83 (401): 231–41.","code":""},{"path":[]},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draw bootstrap replicates — draw.bootstrap","text":"Johannes Gussenbauer, Alexander Kowarik, Statistics Austria","code":""},{"path":"https://statistikat.github.io/surveysd/reference/draw.bootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw bootstrap replicates — draw.bootstrap","text":"","code":"library(surveysd) library(data.table) setDTthreads(1) set.seed(1234) eusilc <- demo.eusilc(n = 3, prettyNames = TRUE)  ## draw replicates without stratification or clustering dat_boot <- draw.bootstrap(eusilc, REP = 1, weights = \"pWeight\",                            period = \"year\")  ## use stratification w.r.t. region and clustering w.r.t. households dat_boot <- draw.bootstrap(   eusilc, REP = 1, hid = \"hid\", weights = \"pWeight\",   strata = \"region\", period = \"year\")  ## use multi-level clustering dat_boot <- draw.bootstrap(   eusilc, REP = 1, hid = \"hid\", weights = \"pWeight\",   strata = c(\"region\", \"hsize\"), period = \"year\")   # create spit households eusilc[, pidsplit := pid] #>          hid  hsize        region    pid       age gender   ecoStat citizenship #>        <int> <fctr>        <fctr>  <int>    <fctr> <fctr>    <fctr>      <fctr> #>     1:     1      3         Tyrol    101   (25,45] female part time          AT #>     2:     1      3         Tyrol    102   (25,45]   male full time       Other #>     3:     1      3         Tyrol    103 (-Inf,16]   male      <NA>        <NA> #>     4:     2      4         Tyrol    201   (25,45] female  domestic          AT #>     5:     2      4         Tyrol    202   (25,45]   male full time          AT #>    ---                                                                          #> 44477:  8999      4 Lower Austria 899904 (-Inf,16] female education          AT #> 44478:  9000      1 Upper Austria 900001   (25,45] female full time          AT #> 44479:  5999      1         Tyrol 599901   (25,45]   male full time          AT #> 44480:  7500      2         Tyrol 750001   (45,65]   male full time          AT #> 44481:  7500      2         Tyrol 750002   (45,65] female  disabled          AT #>          py010n py050n  py090n py100n py110n py120n py130n py140n hy040n #>           <num>  <num>   <num>  <num>  <num>  <num>  <num>  <num>  <num> #>     1:  9756.25      0    0.00      0      0      0      0      0 4273.9 #>     2: 12471.60      0    0.00      0      0      0      0      0 4273.9 #>     3:       NA     NA      NA     NA     NA     NA     NA     NA 4273.9 #>     4: 12487.03      0    0.00      0      0      0      0      0    0.0 #>     5: 42821.23      0    0.00      0      0      0      0      0    0.0 #>    ---                                                                   #> 44477:     0.00      0    0.00      0      0      0      0      0    0.0 #> 44478: 13962.56      0    0.00      0      0      0      0      0    0.0 #> 44479: 14685.18      0    0.00      0      0      0      0      0    0.0 #> 44480: 20606.82      0    0.00      0      0      0      0      0    0.0 #> 44481:     0.00      0 3825.63      0      0      0      0      0    0.0 #>         hy050n hy070n hy080n hy090n hy110n hy130n hy145n  eqSS eqIncome #>          <num>  <num>  <num>  <num>  <num>  <num>  <num> <num>    <num> #>     1: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     2: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     3: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     4: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>     5: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>    ---                                                                  #> 44477: 1955.19      0      0   0.00      0      0      0   2.5 26970.02 #> 44478:    0.00      0      0 424.85      0      0      0   1.0 20242.09 #> 44479:    0.00      0      0 120.65      0      0      0   1.0 14805.83 #> 44480:    0.00      0      0   0.00      0      0      0   1.5 24680.88 #> 44481:    0.00      0      0   0.00      0      0      0   1.5 24680.88 #>           db090  pWeight  year povertyRisk pidsplit #>           <num>    <num> <num>      <lgcl>    <int> #>     1: 504.5696 504.5696  2010       FALSE      101 #>     2: 504.5696 504.5696  2010       FALSE      102 #>     3: 504.5696 504.5696  2010       FALSE      103 #>     4: 493.3824 493.3824  2010       FALSE      201 #>     5: 493.3824 493.3824  2010       FALSE      202 #>    ---                                              #> 44477: 556.4260 556.4260  2012       FALSE   899904 #> 44478: 643.2557 643.2557  2012       FALSE   900001 #> 44479: 679.7288 679.7288  2012       FALSE   599901 #> 44480: 567.1544 567.1544  2012       FALSE   750001 #> 44481: 567.1544 567.1544  2012       FALSE   750002 year <- eusilc[, unique(year)] year <- year[-1] leaf_out <- c() for(y in year) {   split.person <- eusilc[     year == (y-1) & !duplicated(hid) & !(hid %in% leaf_out),     sample(pid, 20)   ]   overwrite.person <- eusilc[     (year == (y)) & !duplicated(hid) & !(hid %in% leaf_out),     .(pid = sample(pid, 20))   ]   overwrite.person[, c(\"pidsplit\", \"year_curr\") := .(split.person, y)]    eusilc[overwrite.person, pidsplit := i.pidsplit,          on = .(pid, year >= year_curr)]   leaf_out <- c(leaf_out,                 eusilc[pid %in% c(overwrite.person$pid,                                   overwrite.person$pidsplit),                 unique(hid)]) }  dat_boot <- draw.bootstrap(   eusilc, REP = 1, hid = \"hid\", weights = \"pWeight\",   strata = c(\"region\", \"hsize\"), period = \"year\", split = TRUE,   pid = \"pidsplit\") # split households were considered e.g. household and # split household were both selected or not selected dat_boot[, data.table::uniqueN(w1), by = pidsplit][V1 > 1] #> Empty data.table (0 rows and 2 cols): pidsplit,V1"},{"path":"https://statistikat.github.io/surveysd/reference/generate.HHID.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","title":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","text":"Generating new houshold ID survey data using houshold ID personal ID. surveys rotating panel design containing housholds, houshold members can move existing household new one, originally sample. leads creation called split households. Using peronal ID (stays fixed whole survey), indicator different time steps houshold ID, new houshold ID assigned original split household.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/generate.HHID.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","text":"","code":"generate.HHID(dat, period = \"RB010\", pid = \"RB030\", hid = \"DB030\")"},{"path":"https://statistikat.github.io/surveysd/reference/generate.HHID.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","text":"dat data table data frame containing survey data period column name dat containing indicator rotations, e.g years, quarters, months, ect... pid column name dat containing personal identifier. needs fixed indiviual throught whole survey hid column name dat containing household id. needs household throught whole survey","code":""},{"path":"https://statistikat.github.io/surveysd/reference/generate.HHID.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","text":"survey data dat data.table object containing new old household ID. new household ID considers split households now named hid original household ID trailing \"_orig\".","code":""},{"path":"https://statistikat.github.io/surveysd/reference/generate.HHID.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate new houshold ID for survey data with rotating panel design taking into account split households — generate.HHID","text":"","code":"if (FALSE) { # \\dontrun{ library(surveysd) library(laeken) library(data.table)  eusilc <- surveysd:::demo.eusilc(n=4)  # create spit households eusilc[,rb030split:=rb030] year <- eusilc[,unique(year)] year <- year[-1] leaf_out <- c() for(y in year) {   split.person <- eusilc[year==(y-1)&!duplicated(db030)&!db030%in%leaf_out,                          sample(rb030,20)]   overwrite.person <- eusilc[year==(y)&!duplicated(db030)&!db030%in%leaf_out,                              .(rb030=sample(rb030,20))]   overwrite.person[,c(\"rb030split\",\"year_curr\"):=.(split.person,y)]    eusilc[overwrite.person,          rb030split:=i.rb030split,on=.(rb030,year>=year_curr)]   leaf_out <- c(     leaf_out,     eusilc[rb030%in%c(overwrite.person$rb030,overwrite.person$rb030split),     unique(db030)]) }  # pid which are in split households eusilc[,.(uniqueN(db030)),by=list(rb030split)][V1>1]  eusilc.new <- generate.HHID(eusilc, period = \"year\", pid = \"rb030split\",                             hid = \"db030\")  # no longer any split households in the data eusilc.new[,.(uniqueN(db030)),by=list(rb030split)][V1>1] } # }"},{"path":"https://statistikat.github.io/surveysd/reference/get.selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","title":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","text":"Reconstruct sample selection, e.g. record drawn drawn (delta = 0/1) sampling stage bootstrap replicates. get.selection() needs cluster, strata hid/pid information (NULL) correctly reconstruct record drawn sampling stage bootstrap replicate. needed bootstrap replicates drawn survey existing bootstrap replicates previous period, see parameter already.selected function draw.bootstrap().","code":""},{"path":"https://statistikat.github.io/surveysd/reference/get.selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","text":"","code":"get.selection(   dat,   b.rep = attr(dat, \"b.rep\"),   strata = attr(dat, \"strata\"),   cluster = attr(dat, \"cluster\"),   hid = attr(dat, \"hid\"),   pid = attr(dat, \"pid\") )"},{"path":"https://statistikat.github.io/surveysd/reference/get.selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","text":"dat either data.frame data.table containing survey data rotating panel design. contain survey data single time period. b.rep character specifying names columns dat containing bootstrap replicates. strata character vector specifying name(s) column dat population stratified. cluster character vector specifying cluster data. hid character specifying name column dat containing household id. NULL (default), household structure regarded. hid pid NULL. pid pid column dat specifying personal identifier. identifier needs unique person throught whole data set. hid pid NULL.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/get.selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","text":"Returns list data.tables. length list equals number sampling stages specified. list entry contains data.table variables sampling stage /hid/pid well length(attr(dat,\"b.rep\")) columns indicating record/cluster drawn respective sampling stage -th boostrap replicate.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/get.selection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get sample selection (~deltas) from drawn bootstrap replicates — get.selection","text":"","code":"library(surveysd) library(data.table) setDTthreads(1) set.seed(1234) eusilc <- demo.eusilc(n = 3, prettyNames = TRUE)  ## draw replicates with stratification dat_boot <- draw.bootstrap(eusilc[year<2012], REP = 3, weights = \"pWeight\",                            strata = \"region\", hid = \"hid\",                            period = \"year\")  ## get selection matrix for year 2011  dat_selection <- get.selection(dat_boot[year==2011]) print(dat_selection) #> $SamplingStage1 #> Key: <region, hid> #>           region   hid delta_1_1 delta_1_2 delta_1_3 #>           <fctr> <int>    <lgcl>    <lgcl>    <lgcl> #>    1: Burgenland    12     FALSE     FALSE      TRUE #>    2: Burgenland    59     FALSE     FALSE      TRUE #>    3: Burgenland   112     FALSE      TRUE      TRUE #>    4: Burgenland   135     FALSE      TRUE      TRUE #>    5: Burgenland   170     FALSE      TRUE     FALSE #>   ---                                                #> 5996: Vorarlberg  7384     FALSE     FALSE      TRUE #> 5997: Vorarlberg  7396      TRUE     FALSE     FALSE #> 5998: Vorarlberg  7437     FALSE     FALSE      TRUE #> 5999: Vorarlberg  7445     FALSE     FALSE     FALSE #> 6000: Vorarlberg  7488      TRUE     FALSE      TRUE #>   ## draw bootstrap replicates for year 2012 ## respecting already selected units for year 2011 ~ dat_selection ## in order to mimic rotating panel design dat_boot_2012 <- draw.bootstrap(eusilc[year==2012], REP = 3, weights = \"pWeight\",                                 strata = \"region\", hid = \"hid\",                                 period = \"year\",                                  already.selected = dat_selection)"},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":null,"dir":"Reference","previous_headings":"","what":"Iterative Proportional Fitting — ipf","title":"Iterative Proportional Fitting — ipf","text":"Adjust sampling weights given totals based household-level /individual level constraints.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iterative Proportional Fitting — ipf","text":"","code":"ipf(   dat,   hid = NULL,   conP = NULL,   conH = NULL,   epsP = 1e-06,   epsH = 0.01,   verbose = FALSE,   w = NULL,   bound = 4,   maxIter = 200,   meanHH = TRUE,   allPthenH = TRUE,   returnNA = TRUE,   looseH = FALSE,   numericalWeighting = computeLinear,   check_hh_vars = TRUE,   conversion_messages = FALSE,   nameCalibWeight = \"calibWeight\",   minMaxTrim = NULL,   print_every_n = 100 )"},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iterative Proportional Fitting — ipf","text":"dat data.table containing household ids (optionally), base weights (optionally), household /personal level variables (numerical categorical) fitted. hid name column containing household-ids within dat NULL variable exist. conP list (partly) named list defining constraints person level.  list elements contingency tables array representation dimnames corresponding names relevant calibration variables dat. numerical variable calibrated, respective list element named name numerical variable. Otherwise list element shoud named. conH list (partly) named list defining constraints household level.  list elements contingency tables array representation dimnames corresponding names relevant calibration variables dat. numerical variable calibrated, respective list element named name numerical variable. Otherwise list element shoud named. epsP numeric value list (numeric values /arrays) specifying convergence limit(s) conP. list can contain numeric values /arrays must appear order corresponding constraints conP. Also, array must dimensions dimnames corresponding constraint conP. epsH numeric value list (numeric values /arrays) specifying convergence limit(s) conH. list can contain numeric values /arrays must appear order corresponding constraints conH. Also, array must dimensions dimnames corresponding constraint conH. verbose TRUE, progress information printed. w name column containing base weights within dat NULL variable exist. latter case, every observation dat assigned starting weight 1. bound numeric value specifying multiplier determining weight trimming boundary change base weights restricted, .e. weights stay 1/bound*w bound*w. maxIter numeric value specifying maximum number iterations performed. meanHH TRUE, every person household assigned mean person weights corresponding household. \"geometric\", geometric mean used rather arithmetic mean. allPthenH TRUE, person level calibration steps performed houshold level calibration steps (meanHH, specified). FALSE, houshold level calibration steps (meanHH, specified) performed everey person level calibration step. can lead better convergence properties certain cases also means total number calibration steps increased. returnNA TRUE, calibrated weight set NA case convergence. looseH FALSE, actual constraints conH used calibrating hh weights. TRUE, weights lower upper thresholds defined conH epsH exceeded calibrated. however calibrated actual constraints conH lower upper thresholds, .e. conH-conH*epsH conH+conH*epsH. numericalWeighting See numericalWeighting check_hh_vars TRUE check non-unique values inside household variables household constraints conversion_messages show message, inputs need reformatted. can useful speed optimizations ipf called several times similar inputs (example bootstrapping) nameCalibWeight character defining name variable newly generated calibrated weight. minMaxTrim numeric vector length2, first element minimum value weights trimmed , second element maximum value weights trimmed . print_every_n number interation steps summary table printed. summary table shows constraints yet reached according epsP epsH","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iterative Proportional Fitting — ipf","text":"function return input data dat calibrated weights calibWeight additional column well attributes. convergence reached maxIter steps, returnNA TRUE (default), column calibWeights consist NAs. attributes table attributes derived data.table class well following.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Iterative Proportional Fitting — ipf","text":"function implements weighting procedure described : doi:10.17713/ajs.v45i3.120 . Usage examples can found corresponding vignette (vignette(\"ipf\")). conP conH contingency tables, can created xtabs. dimnames tables match names levels corresponding columns dat. maxIter, epsP epsH stopping criteria. epsP epsH describe relative tolerances sense $$1-epsP < \\frac{w_{+1}}{w_i} < 1+epsP$$ used convergence criterium. iteration step wi weight specific person step . algorithm performs best varables occuring constraints (conP conH) well household variable coded factor-columns dat. Otherwise, conversions necessary can monitored conversion_messages argument. Setting check_hh_vars FALSE can also incease performance scheme.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Iterative Proportional Fitting — ipf","text":"Alexander Kowarik, Gregor de Cillia","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iterative Proportional Fitting — ipf","text":"","code":"if (FALSE) { # \\dontrun{  # load data eusilc <- demo.eusilc(n = 1, prettyNames = TRUE)  # personal constraints conP1 <- xtabs(pWeight ~ age, data = eusilc) conP2 <- xtabs(pWeight ~ gender + region, data = eusilc) conP3 <- xtabs(pWeight*eqIncome ~ gender, data = eusilc)  # household constraints conH1 <- xtabs(pWeight ~ hsize + region, data = eusilc[!duplicated(hid)])  # simple usage ------------------------------------------  calibweights1 <- ipf(   eusilc,   conP = list(conP1, conP2, eqIncome = conP3),   bound = NULL,   verbose = TRUE )  # compare personal weight with the calibweigth calibweights1[, .(hid, pWeight, calibWeight)]  # advanced usage ----------------------------------------  # use an array of tolerances epsH1 <- conH1 epsH1[1:4, ] <- 0.005 epsH1[5, ] <- 0.2  # create an initial weight for the calibration eusilc[, regSamp := .N, by = region] eusilc[, regPop := sum(pWeight), by = region] eusilc[, baseWeight := regPop/regSamp]  calibweights2 <- ipf(   eusilc,   conP = list(conP1, conP2),   conH = list(conH1),   epsP = 1e-6,   epsH = list(epsH1),   bound = 4,   w = \"baseWeight\",   verbose = TRUE )  # show an adjusted version of conP and the original attr(calibweights2, \"conP_adj\") attr(calibweights2, \"conP\") } # }"},{"path":"https://statistikat.github.io/surveysd/reference/ipf_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform one step of iterative proportional updating — ipf_step","title":"Perform one step of iterative proportional updating — ipf_step","text":"C++ routines invoke single iteration Iterative proportional updating (IPU) scheme. Targets classes assumed one dimensional ipf_step functions. combine_factors aggregates several vectors type factor single one allow multidimensional ipu-steps. See examples.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform one step of iterative proportional updating — ipf_step","text":"","code":"ipf_step_ref(w, classes, targets)  ipf_step(w, classes, targets)  ipf_step_f(w, classes, targets)  combine_factors(dat, targets)"},{"path":"https://statistikat.github.io/surveysd/reference/ipf_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform one step of iterative proportional updating — ipf_step","text":"w numeric vector weights. entries positive. classes factor variable. Must length w. targets key figure target ipu scheme. numeric verctor length levels(classes). can also table produced xtabs. See examples. dat data.frame containing factor variables combined.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf_step.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform one step of iterative proportional updating — ipf_step","text":"ipf_step returns adjusted weights. ipf_step_ref , updates w reference rather returning. ipf_step_f returns multiplicator: adjusted weights divided unadjusted weights. combine_factors designed make ipf_step work contingency tables produced xtabs.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/ipf_step.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform one step of iterative proportional updating — ipf_step","text":"","code":"############# one-dimensional ipu ##############  ## create random data nobs <- 10 classLabels <- letters[1:3] dat = data.frame(   weight = exp(rnorm(nobs)),   household = factor(sample(classLabels, nobs, replace = TRUE)) ) dat #>       weight household #> 1  1.1642146         a #> 2  1.2417372         a #> 3  0.9976603         c #> 4  1.0338712         b #> 5  4.3572598         c #> 6  0.6061090         c #> 7  1.1190749         a #> 8  0.3614024         b #> 9  0.5411144         b #> 10 3.4322315         c  ## create targets (same lenght as classLabels!) targets <- 3:5  ## calculate weights new_weight <- ipf_step(dat$weight, dat$household, targets) cbind(dat, new_weight) #>       weight household new_weight #> 1  1.1642146         a  0.9908134 #> 2  1.2417372         a  1.0567896 #> 3  0.9976603         c  0.5310511 #> 4  1.0338712         b  2.1356696 #> 5  4.3572598         c  2.3193543 #> 6  0.6061090         c  0.3226297 #> 7  1.1190749         a  0.9523969 #> 8  0.3614024         b  0.7465495 #> 9  0.5411144         b  1.1177809 #> 10 3.4322315         c  1.8269649  ## check solution xtabs(new_weight ~ dat$household) #> dat$household #> a b c  #> 3 4 5   ## calculate weights \"by reference\" ipf_step_ref(dat$weight, dat$household, targets) dat #>       weight household #> 1  0.9908134         a #> 2  1.0567896         a #> 3  0.5310511         c #> 4  2.1356696         b #> 5  2.3193543         c #> 6  0.3226297         c #> 7  0.9523969         a #> 8  0.7465495         b #> 9  1.1177809         b #> 10 1.8269649         c  ############# multidimensional ipu ##############  ## load data factors <- c(\"time\", \"sex\", \"smoker\", \"day\") tips <- data.frame(sex=c(\"Female\",\"Male\",\"Male\"), day=c(\"Sun\",\"Mon\",\"Tue\"), time=c(\"Dinner\",\"Lunch\",\"Lunch\"), smoker=c(\"No\",\"Yes\",\"No\")) tips <- tips[factors]  ## combine factors con <- xtabs(~., tips) cf <- combine_factors(tips, con) cbind(tips, cf)[sample(nrow(tips), 10, replace = TRUE),] #>       time    sex smoker day cf #> 2    Lunch   Male    Yes Mon  8 #> 2.1  Lunch   Male    Yes Mon  8 #> 3    Lunch   Male     No Tue 20 #> 3.1  Lunch   Male     No Tue 20 #> 1   Dinner Female     No Sun  9 #> 2.2  Lunch   Male    Yes Mon  8 #> 3.2  Lunch   Male     No Tue 20 #> 1.1 Dinner Female     No Sun  9 #> 2.3  Lunch   Male    Yes Mon  8 #> 1.2 Dinner Female     No Sun  9  ## adjust weights weight <- rnorm(nrow(tips)) + 5 adjusted_weight <- ipf_step(weight, cf, con)  ## check outputs con2 <- xtabs(adjusted_weight ~ ., data = tips) sum((con - con2)^2) #> [1] 0"},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":null,"dir":"Reference","previous_headings":"","what":"Kish Factor — kishFactor","title":"Kish Factor — kishFactor","text":"Compute design effect due unequal weighting.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kish Factor — kishFactor","text":"","code":"kishFactor(w, na.rm = FALSE)"},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kish Factor — kishFactor","text":"w numeric vector weights na.rm logical value indicating whether NA values stripped computation proceeds.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kish Factor — kishFactor","text":"function return kish factor","code":""},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kish Factor — kishFactor","text":"factor computed acording 'Weighting Unequal P_i', Leslie Kish, Journal Official Statistics, Vol. 8. . 2, 1992 $$ deff = \\sqrt n \\sum_j w_j^2 / (\\sum_j w_j)^2$$","code":""},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Kish Factor — kishFactor","text":"Alexander Kowarik","code":""},{"path":"https://statistikat.github.io/surveysd/reference/kishFactor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kish Factor — kishFactor","text":"","code":"kishFactor(rep(1,10)) #> [1] 1 kishFactor(rlnorm(10)) #> [1] 1.35633"},{"path":"https://statistikat.github.io/surveysd/reference/plot.surveysd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot surveysd-Objects — plot.surveysd","title":"Plot surveysd-Objects — plot.surveysd","text":"Plot results calc.stError()","code":""},{"path":"https://statistikat.github.io/surveysd/reference/plot.surveysd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot surveysd-Objects — plot.surveysd","text":"","code":"# S3 method for class 'surveysd' plot(   x,   variable = x$param$var[1],   type = c(\"summary\", \"grouping\"),   groups = NULL,   sd.type = c(\"dot\", \"ribbon\"),   ... )"},{"path":"https://statistikat.github.io/surveysd/reference/plot.surveysd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot surveysd-Objects — plot.surveysd","text":"x object class 'surveysd' output function calc.stError variable Name variable standard errors calcualated dat type can bei either \"summary\" \"grouping\", default value \"summary\". \"summary\" barplot created giving overview number estimates flag smallGroup, cvHigh, none . 'grouping' results point estimate standard error plotted pre defined groups. groups type='grouping' variables must defined data grouped. 2 levels supported right now. one group defined higher group estimate whole period. Results plotted first argument groups well combination groups[1] groups[2]. sd.type can bei either 'ribbon' 'dot' used type='grouping'. Default \"dot\" sd.type='dot' point estimates plotted flagged corresponding standard error /standard error using mean k-periods exceeded value cv.limit (see calc.stError). sd.type='ribbon' point estimates including ribbons, defined point estimate +- estimated standard error plotted. calculated standard errors using mean k periods plotted using less transparency. Results higher level (~groups[1]) coloured grey. ... additional arguments supplied plot.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/plot.surveysd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot surveysd-Objects — plot.surveysd","text":"","code":"library(surveysd)  set.seed(1234) eusilc <- demo.eusilc(n = 3, prettyNames = TRUE)  dat_boot <- draw.bootstrap(eusilc, REP = 3, hid = \"hid\", weights = \"pWeight\",                            strata = \"region\", period = \"year\")  # calibrate weight for bootstrap replicates dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\") #> Iteration stopped after 2 steps #> Convergence reached #> 10:Not yet converged for P-Constraint1 #> 10:Not yet converged for H-Constraint1 #> 20:Not yet converged for P-Constraint1 #> 20:Not yet converged for H-Constraint1 #> 30:Not yet converged for P-Constraint1 #> 30:Not yet converged for H-Constraint1 #> 40:Not yet converged for P-Constraint1 #> 40:Not yet converged for H-Constraint1 #> 50:Not yet converged for P-Constraint1 #> 50:Not yet converged for H-Constraint1 #> 60:Not yet converged for P-Constraint1 #> 60:Not yet converged for H-Constraint1 #> 70:Not yet converged for P-Constraint1 #> 70:Not yet converged for H-Constraint1 #> 80:Not yet converged for P-Constraint1 #> 80:Not yet converged for H-Constraint1 #> 90:Not yet converged for P-Constraint1 #> 90:Not yet converged for H-Constraint1 #> 100:Not yet converged for P-Constraint1 #>      year gender    maxFac     N  epsP CalibMargin PopMargin #>    <fctr> <fctr>     <num> <int> <num>       <num>     <num> #> 1:   2012   male 0.0244125  7267  0.01     4076723   3979572 #> 2:   2012 female 0.0244125  7560  0.01     4305248   4202650 #> 3:   2011   male 0.0207708  7267  0.01     4062231   3979572 #> 4:   2011 female 0.0207708  7560  0.01     4289943   4202650 #> ----------------------------------------- #> 100:Not yet converged for H-Constraint1 #>       year        region     maxFac     N  epsH sumCalibWeight PopMargin #>     <fctr>        <fctr>      <num> <int> <num>          <num>     <num> #>  1:   2012      Salzburg 0.02383074   924  0.02       214443.9    219679 #>  2:   2012 Upper Austria 0.02383074  2805  0.02       553498.7    567011 #>  3:   2012 Lower Austria 0.02383074  2804  0.02       631933.9    647361 #>  4:   2012    Vorarlberg 0.02383074   733  0.02       141539.7    144995 #>  5:   2012         Tyrol 0.02383074  1317  0.02       272367.8    279017 #>  6:   2012     Carinthia 0.02383074  1078  0.02       228175.7    233746 #>  7:   2012    Burgenland 0.02383074   549  0.02       107228.3    109846 #>  8:   2012        Styria 0.02383074  2295  0.02       478680.2    490366 #>  9:   2012        Vienna 0.02383074  2322  0.02       793746.7    813124 #> 10:   2011    Vorarlberg 0.02034815   733  0.02       142044.6    144995 #> 11:   2011 Upper Austria 0.02034815  2805  0.02       555473.4    567011 #> 12:   2011         Tyrol 0.02034815  1317  0.02       273339.5    279017 #> 13:   2011      Salzburg 0.02034815   924  0.02       215208.9    219679 #> 14:   2011        Styria 0.02034815  2295  0.02       480388.0    490366 #> 15:   2011 Lower Austria 0.02034815  2804  0.02       634188.4    647361 #> 16:   2011    Burgenland 0.02034815   549  0.02       107610.8    109846 #> 17:   2011        Vienna 0.02034815  2322  0.02       796578.4    813124 #> 18:   2011     Carinthia 0.02034815  1078  0.02       228989.7    233746 #> ----------------------------------------- #> 110:Not yet converged for P-Constraint1 #> 110:Not yet converged for H-Constraint1 #> 120:Not yet converged for P-Constraint1 #> 120:Not yet converged for H-Constraint1 #> 130:Not yet converged for P-Constraint1 #> 130:Not yet converged for H-Constraint1 #> 140:Not yet converged for P-Constraint1 #> 140:Not yet converged for H-Constraint1 #> 150:Not yet converged for P-Constraint1 #> 150:Not yet converged for H-Constraint1 #> 160:Not yet converged for P-Constraint1 #> 160:Not yet converged for H-Constraint1 #> 170:Not yet converged for P-Constraint1 #> 170:Not yet converged for H-Constraint1 #> 180:Not yet converged for P-Constraint1 #> 180:Not yet converged for H-Constraint1 #> 190:Not yet converged for P-Constraint1 #> 190:Not yet converged for H-Constraint1 #> 200:Not yet converged for P-Constraint1 #>      year gender    maxFac     N  epsP CalibMargin PopMargin #>    <fctr> <fctr>     <num> <int> <num>       <num>     <num> #> 1:   2012 female 0.0244125  7560  0.01     4305248   4202650 #> 2:   2012   male 0.0244125  7267  0.01     4076723   3979572 #> 3:   2011 female 0.0207708  7560  0.01     4289943   4202650 #> 4:   2011   male 0.0207708  7267  0.01     4062231   3979572 #> ----------------------------------------- #> 200:Not yet converged for H-Constraint1 #>       year        region     maxFac     N  epsH sumCalibWeight PopMargin #>     <fctr>        <fctr>      <num> <int> <num>          <num>     <num> #>  1:   2012 Upper Austria 0.02383074  2805  0.02       553498.7    567011 #>  2:   2012      Salzburg 0.02383074   924  0.02       214443.9    219679 #>  3:   2012     Carinthia 0.02383074  1078  0.02       228175.7    233746 #>  4:   2012         Tyrol 0.02383074  1317  0.02       272367.8    279017 #>  5:   2012 Lower Austria 0.02383074  2804  0.02       631933.9    647361 #>  6:   2012    Burgenland 0.02383074   549  0.02       107228.3    109846 #>  7:   2012    Vorarlberg 0.02383074   733  0.02       141539.7    144995 #>  8:   2012        Styria 0.02383074  2295  0.02       478680.2    490366 #>  9:   2012        Vienna 0.02383074  2322  0.02       793746.7    813124 #> 10:   2011    Burgenland 0.02034815   549  0.02       107610.8    109846 #> 11:   2011 Lower Austria 0.02034815  2804  0.02       634188.4    647361 #> 12:   2011      Salzburg 0.02034815   924  0.02       215208.9    219679 #> 13:   2011         Tyrol 0.02034815  1317  0.02       273339.5    279017 #> 14:   2011     Carinthia 0.02034815  1078  0.02       228989.7    233746 #> 15:   2011        Styria 0.02034815  2295  0.02       480388.0    490366 #> 16:   2011        Vienna 0.02034815  2322  0.02       796578.4    813124 #> 17:   2011 Upper Austria 0.02034815  2805  0.02       555473.4    567011 #> 18:   2011    Vorarlberg 0.02034815   733  0.02       142044.6    144995 #> ----------------------------------------- #> Warning: Not converged in 200 steps #> No convergence reached #> Iteration stopped after 1 steps #> Convergence reached #> Calibration failed for bootstrap replicates w2  #> Corresponding bootstrap replicates will be discarded #> Returning 2 calibrated bootstrap weights  # estimate weightedRatio for povmd60 per period group <- list(\"gender\", \"region\", c(\"gender\", \"region\")) err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\",                         fun = weightedRatio,                         group = group , period.mean = NULL)   plot(err.est)   # plot results for gender # dotted line is the result on the national level plot(err.est, type = \"grouping\", groups = \"gender\") #> Warning: No shared levels found between `names(values)` of the manual scale and the #> data's shape values.    # plot results for rb090 in each db040 # with standard errors as ribbons plot(err.est, type = \"grouping\", groups = c(\"gender\", \"region\"), sd.type = \"ribbon\")"},{"path":"https://statistikat.github.io/surveysd/reference/print.summary.ipf.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for IPF calibration summary — print.summary.ipf","title":"Print method for IPF calibration summary — print.summary.ipf","text":"Provides concise summary IPF (Iterative Proportional Fitting) calibration summary object. extracts calibration weight all_formulas, computes Kish factor weights, prints first 10 rows calib_results_ tables. Useful quick overview calibration results. Additional details can explored str() names().","code":""},{"path":"https://statistikat.github.io/surveysd/reference/print.summary.ipf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for IPF calibration summary — print.summary.ipf","text":"","code":"# S3 method for class 'summary.ipf' print(x, ...)"},{"path":"https://statistikat.github.io/surveysd/reference/print.summary.ipf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for IPF calibration summary — print.summary.ipf","text":"x object class summary.ipf, returned summary.ipf. ... Additional arguments (currently ignored).","code":""},{"path":"https://statistikat.github.io/surveysd/reference/print.summary.ipf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for IPF calibration summary — print.summary.ipf","text":"input object x, invisibly (chaining).","code":""},{"path":"https://statistikat.github.io/surveysd/reference/print.surveysd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print function for surveysd objects — print.surveysd","title":"Print function for surveysd objects — print.surveysd","text":"Prints results call calc.stError. Shows used variables function, number point estiamtes well properties results.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/print.surveysd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print function for surveysd objects — print.surveysd","text":"","code":"# S3 method for class 'surveysd' print(x, ...)"},{"path":"https://statistikat.github.io/surveysd/reference/print.surveysd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print function for surveysd objects — print.surveysd","text":"x object class 'surveysd' ... additonal parameters","code":""},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate weights — recalib","title":"Calibrate weights — recalib","text":"Calibrate weights bootstrap replicates using iterative proportional updating match population totals various household personal levels.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate weights — recalib","text":"","code":"recalib(   dat,   hid = attr(dat, \"hid\"),   weights = attr(dat, \"weights\"),   b.rep = attr(dat, \"b.rep\"),   period = attr(dat, \"period\"),   conP.var = NULL,   conH.var = NULL,   conP = NULL,   conH = NULL,   epsP = 0.01,   epsH = 0.02,   ... )"},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate weights — recalib","text":"dat either data.frame data.table containing sample survey various periods. hid character specifying name column dat containing household ID. weights character specifying name column dat containing sample weights. b.rep character specifying names columns dat containing bootstrap weights recalibratet period character specifying name column dat containing sample period. conP.var character vector containig person-specific variables weights calibrated list character vectors. Contingency tables population calculated per period using weights. vector supplied contingency tables calculated vector entry. list supplied contingency tables calculated list entry. See examples details. conH.var character vector containig household-specific variables weights calibrated list character vectors. Contingency tables population calculated per period using weights. vector supplied contingency tables calculated vector entry. list supplied contingency tables calculated list entry. See examples details. conP list (partly) named list defining constraints person level.  list elements contingency tables array representation dimnames corresponding names relevant calibration variables dat. numerical variable calibrated, respective list element named name numerical variable. Otherwise list element shoud named. conH list (partly) named list defining constraints household level.  list elements contingency tables array representation dimnames corresponding names relevant calibration variables dat. numerical variable calibrated, respective list element named name numerical variable. Otherwise list element shoud named. epsP numeric value specifying convergence limit conP.var conP, see ipf(). epsH numeric value specifying convergence limit conH.var conH, see ipf(). ... additional arguments passed function ipf() package.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate weights — recalib","text":"Returns data.table containing survey data well calibrated weights bootstrap replicates. original bootstrap replicates overwritten calibrated weights. calibration bootstrap replicate converge bootsrap weight returned numeration returned bootstrap weights reduced one.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calibrate weights — recalib","text":"recalib takes survey data (dat) containing bootstrap replicates generated draw.bootstrap calibrates weights bootstrap replication according population totals person- household-specific variables. dat must household data household members correspond multiple rows household identifier. data least containt following columns: Column indicating sample period; Column indicating household ID; Column containing household sample weights; Columns contain bootstrap replicates (see output draw.bootstrap); Columns indicating person- household-specific variables sample weight adjusted. period variable conP.var /conH.var contingency tables estimated get margin totals personal- /household-specific variables population. Afterwards bootstrap replicates multiplied original sample weight resulting product ist adjusted using ipf() match previously calcualted contingency tables. process columns bootstrap replicates overwritten calibrated weights.","code":""},{"path":[]},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calibrate weights — recalib","text":"Johannes Gussenbauer, Alexander Kowarik, Statistics Austria","code":""},{"path":"https://statistikat.github.io/surveysd/reference/recalib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calibrate weights — recalib","text":"","code":"library(surveysd) library(data.table) setDTthreads(1) set.seed(1234) eusilc <- demo.eusilc(n = 3, prettyNames = TRUE)  dat_boot <- draw.bootstrap(eusilc, REP = 1, hid = \"hid\",                            weights = \"pWeight\",                            strata = \"region\", period = \"year\")  # calibrate weight for bootstrap replicates dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\",                           verbose = TRUE) #> Iteration stopped after 3 steps #> Convergence reached   # calibrate on other variables dat_boot_calib <- recalib(dat_boot, conP.var = c(\"gender\", \"age\"),                           conH.var = c(\"region\", \"hsize\"), verbose = TRUE) #> Iteration stopped after 3 steps #> Convergence reached  # supply contingency tables directly conP1 <- xtabs(pWeight ~ age + year, data = eusilc) conP2 <- xtabs(pWeight ~ gender + year, data = eusilc) conH1 <- xtabs(pWeight ~ region + year,                data = eusilc[!duplicated(paste(hid,year))]) conH2 <- xtabs(pWeight ~ hsize + year,                data = eusilc[!duplicated(paste(hid,year))])  conP <- list(conP1,conP2) conH <- list(conH1,conH2) dat_boot_calib <- recalib(dat_boot, conP.var = NULL,                           conH.var = NULL, conP = conP,                           conH = conH, verbose = TRUE) #> Iteration stopped after 3 steps #> Convergence reached   # calibrate on gender x age dat_boot_calib <- recalib(dat_boot, conP.var = list(c(\"gender\", \"age\")),                           conH.var = NULL, verbose = TRUE) #> Iteration stopped after 6 steps #> Convergence reached  # identical conP1 <- xtabs(pWeight ~ age + gender + year, data = eusilc) conP <- list(conP1) dat_boot_calib <- recalib(dat_boot, conP.var = NULL,                           conH.var = NULL, conP = conP,                           conH = NULL, verbose = TRUE) #> Iteration stopped after 6 steps #> Convergence reached"},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw bootstrap replicates — rescaled.bootstrap","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"Draw bootstrap replicates survey data using either rescaled bootstrap stratified multistage sampling, presented J. Preston (2009) Rao-Wu boostrap J. N. K. Rao C. F. J. Wu (1988)","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"","code":"rescaled.bootstrap(   dat,   method = c(\"Preston\", \"Rao-Wu\"),   REP = 1000,   strata = \"DB050>1\",   cluster = \"DB060>DB030\",   fpc = \"N.cluster>N.households\",   single.PSU = c(\"merge\", \"mean\"),   return.value = c(\"data\", \"replicates\"),   run.input.checks = TRUE,   already.selected = NULL,   seed = NULL )"},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"dat either data frame data table containing survey sample method bootstrap replicates, either \"Preston\" \"Rao-Wu\" REP integer indicating number bootstraps drawn strata string specifying column name dat used stratification. multistage sampling multiple column names can specified strata=c(\"strata1\",\"strata2\",\"strata3\") strata=c(\"strata1>strata2>strata3\"). See Details information. cluster string specifying column name dat used clustering. instance given household sample column containing household ID supplied. multistage sampling multiple column names can specified cluster=c(\"cluster1\",\"cluster2\",\"cluster3\") cluster=c(\"cluster1>cluster2>cluster3\"). See Details information. fpc string specifying column name dat contains number PSUs first stage. multistage sampling number PSUs stage must specified strata=c(\"fpc1\",\"fpc2\",\"fpc3\") strata=c(\"fpc1>fpc2>fpc3\"). single.PSU either \"merge\" \"mean\" defining single PSUs need dealt . single.PSU=\"merge\" single PSUs stage merged strata cluster next least number PSUs. multiple exist one select via random draw. single.PSU=\"mean\" single PSUs get mean bootstrap replicates stage contain single PSUs. return.value either \"data\", \"replicates\" /\"selection\" specifying return value function. \"data\" survey data returned class data.table, \"replicates\" bootstrap replicates returned data.table. \"selection\" list data.tables length length(strata) returned containing 1:REP 0-1 columns indicating PSU selected sampling stage. run.input.checks logical, TRUE input checked applying bootstrap procedure already.selected list data.tables NULL data.table contains columns cluster, strata additionally 1:REP columns containing 0-1 values indicate PSU selected bootstrap replicate. data.tables corresponds one sampling stages. First entry list corresponds first sampling stage . seed integer specifying seed random number generator.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"returns complete data set including bootstrap replicates just bootstrap replicates, depending return.value=\"data\" return.value=\"replicates\" respectively.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"specifying multistage sampling designs column names strata,cluster fpc need seperated \">\". multistage sampling strings read left right meaning first vector entry column name first \">\" taken column stratification/clustering/number PSUs first last vector entry column last \">\" taken column stratification/clustering/number PSUs last stage. stages sample stratified clustered one must specify \"1\" \"\", e.g. strata=c(\"strata1\",\"\",\"strata3\") strata=c(\"strata1>>strata3\") stratification second stage cluster=c(\"cluster1\",\"cluster2\",\"\") respectively cluster=c(\"cluster1>cluster2>\") clusters last stage. number PSUs stage calculated internally must specified sampling design. single stage sampling using stratification can usually done adding sample weights PSU strata-code. Spaces strings removed, column names contain spaces renamed calling procedure! already.selected supplied sampling bootstrap replicates considers speficif PSUs already selected previous survey wave. specific strata cluster lead floor(n/2) records selected. case records de-selected floor(n/2) records, n total number records, selected strata cluster. parameter ist mostly used draw.bootstrap order consider rotation sampling units time.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"Preston, J. (2009). Rescaled bootstrap stratified multistage sampling. Survey Methodology. 35. 227-234. Rao, J. N. K., C. F. J. Wu. (1988). Resampling Inference Complex Survey Data. Journal American Statistical Association 83 (401): 231–41.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"Johannes Gussenbauer, Eileen Vattheuer, Statistics Austria","code":""},{"path":"https://statistikat.github.io/surveysd/reference/rescaled.bootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw bootstrap replicates — rescaled.bootstrap","text":"","code":"library(surveysd) library(data.table) setDTthreads(1) set.seed(1234) eusilc <- demo.eusilc(n = 1,prettyNames = TRUE)  eusilc[,N.households:=uniqueN(hid),by=region] #>          hid  hsize        region    pid       age gender   ecoStat citizenship #>        <int> <fctr>        <fctr>  <int>    <fctr> <fctr>    <fctr>      <fctr> #>     1:     1      3         Tyrol    101   (25,45] female part time          AT #>     2:     1      3         Tyrol    102   (25,45]   male full time       Other #>     3:     1      3         Tyrol    103 (-Inf,16]   male      <NA>        <NA> #>     4:     2      4         Tyrol    201   (25,45] female  domestic          AT #>     5:     2      4         Tyrol    202   (25,45]   male full time          AT #>    ---                                                                          #> 14823:  5997      4 Lower Austria 599704 (-Inf,16] female education          AT #> 14824:  5998      1 Upper Austria 599801   (25,45] female full time          AT #> 14825:  5999      1         Tyrol 599901   (25,45]   male full time          AT #> 14826:  6000      2         Tyrol 600001   (45,65]   male full time          AT #> 14827:  6000      2         Tyrol 600002   (45,65] female  disabled          AT #>          py010n py050n  py090n py100n py110n py120n py130n py140n hy040n #>           <num>  <num>   <num>  <num>  <num>  <num>  <num>  <num>  <num> #>     1:  9756.25      0    0.00      0      0      0      0      0 4273.9 #>     2: 12471.60      0    0.00      0      0      0      0      0 4273.9 #>     3:       NA     NA      NA     NA     NA     NA     NA     NA 4273.9 #>     4: 12487.03      0    0.00      0      0      0      0      0    0.0 #>     5: 42821.23      0    0.00      0      0      0      0      0    0.0 #>    ---                                                                   #> 14823:     0.00      0    0.00      0      0      0      0      0    0.0 #> 14824: 13962.56      0    0.00      0      0      0      0      0    0.0 #> 14825: 14685.18      0    0.00      0      0      0      0      0    0.0 #> 14826: 20606.82      0    0.00      0      0      0      0      0    0.0 #> 14827:     0.00      0 3825.63      0      0      0      0      0    0.0 #>         hy050n hy070n hy080n hy090n hy110n hy130n hy145n  eqSS eqIncome #>          <num>  <num>  <num>  <num>  <num>  <num>  <num> <num>    <num> #>     1: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     2: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     3: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     4: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>     5: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>    ---                                                                  #> 14823: 1955.19      0      0   0.00      0      0      0   2.5 26508.20 #> 14824:    0.00      0      0 424.85      0      0      0   1.0 14387.41 #> 14825:    0.00      0      0 120.65      0      0      0   1.0 14805.83 #> 14826:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #> 14827:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #>           db090  pWeight  year povertyRisk N.households #>           <num>    <num> <num>      <lgcl>        <int> #>     1: 504.5696 504.5696  2010       FALSE          496 #>     2: 504.5696 504.5696  2010       FALSE          496 #>     3: 504.5696 504.5696  2010       FALSE          496 #>     4: 493.3824 493.3824  2010       FALSE          496 #>     5: 493.3824 493.3824  2010       FALSE          496 #>    ---                                                  #> 14823: 556.4260 556.4260  2010       FALSE         1131 #> 14824: 643.2557 643.2557  2010       FALSE         1068 #> 14825: 679.7288 679.7288  2010       FALSE          496 #> 14826: 567.1544 567.1544  2010       FALSE          496 #> 14827: 567.1544 567.1544  2010       FALSE          496 eusilc.bootstrap <- rescaled.bootstrap(eusilc,REP=10,strata=\"region\",                                        cluster=\"hid\",fpc=\"N.households\")  eusilc[,new_strata:=paste(region,hsize,sep=\"_\")] #>          hid  hsize        region    pid       age gender   ecoStat citizenship #>        <int> <fctr>        <fctr>  <int>    <fctr> <fctr>    <fctr>      <fctr> #>     1:     1      3         Tyrol    101   (25,45] female part time          AT #>     2:     1      3         Tyrol    102   (25,45]   male full time       Other #>     3:     1      3         Tyrol    103 (-Inf,16]   male      <NA>        <NA> #>     4:     2      4         Tyrol    201   (25,45] female  domestic          AT #>     5:     2      4         Tyrol    202   (25,45]   male full time          AT #>    ---                                                                          #> 14823:  5997      4 Lower Austria 599704 (-Inf,16] female education          AT #> 14824:  5998      1 Upper Austria 599801   (25,45] female full time          AT #> 14825:  5999      1         Tyrol 599901   (25,45]   male full time          AT #> 14826:  6000      2         Tyrol 600001   (45,65]   male full time          AT #> 14827:  6000      2         Tyrol 600002   (45,65] female  disabled          AT #>          py010n py050n  py090n py100n py110n py120n py130n py140n hy040n #>           <num>  <num>   <num>  <num>  <num>  <num>  <num>  <num>  <num> #>     1:  9756.25      0    0.00      0      0      0      0      0 4273.9 #>     2: 12471.60      0    0.00      0      0      0      0      0 4273.9 #>     3:       NA     NA      NA     NA     NA     NA     NA     NA 4273.9 #>     4: 12487.03      0    0.00      0      0      0      0      0    0.0 #>     5: 42821.23      0    0.00      0      0      0      0      0    0.0 #>    ---                                                                   #> 14823:     0.00      0    0.00      0      0      0      0      0    0.0 #> 14824: 13962.56      0    0.00      0      0      0      0      0    0.0 #> 14825: 14685.18      0    0.00      0      0      0      0      0    0.0 #> 14826: 20606.82      0    0.00      0      0      0      0      0    0.0 #> 14827:     0.00      0 3825.63      0      0      0      0      0    0.0 #>         hy050n hy070n hy080n hy090n hy110n hy130n hy145n  eqSS eqIncome #>          <num>  <num>  <num>  <num>  <num>  <num>  <num> <num>    <num> #>     1: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     2: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     3: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     4: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>     5: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>    ---                                                                  #> 14823: 1955.19      0      0   0.00      0      0      0   2.5 26508.20 #> 14824:    0.00      0      0 424.85      0      0      0   1.0 14387.41 #> 14825:    0.00      0      0 120.65      0      0      0   1.0 14805.83 #> 14826:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #> 14827:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #>           db090  pWeight  year povertyRisk N.households      new_strata #>           <num>    <num> <num>      <lgcl>        <int>          <char> #>     1: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     2: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     3: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     4: 493.3824 493.3824  2010       FALSE          496         Tyrol_4 #>     5: 493.3824 493.3824  2010       FALSE          496         Tyrol_4 #>    ---                                                                  #> 14823: 556.4260 556.4260  2010       FALSE         1131 Lower Austria_4 #> 14824: 643.2557 643.2557  2010       FALSE         1068 Upper Austria_1 #> 14825: 679.7288 679.7288  2010       FALSE          496         Tyrol_1 #> 14826: 567.1544 567.1544  2010       FALSE          496         Tyrol_2 #> 14827: 567.1544 567.1544  2010       FALSE          496         Tyrol_2 eusilc[,N.housholds:=uniqueN(hid),by=new_strata] #>          hid  hsize        region    pid       age gender   ecoStat citizenship #>        <int> <fctr>        <fctr>  <int>    <fctr> <fctr>    <fctr>      <fctr> #>     1:     1      3         Tyrol    101   (25,45] female part time          AT #>     2:     1      3         Tyrol    102   (25,45]   male full time       Other #>     3:     1      3         Tyrol    103 (-Inf,16]   male      <NA>        <NA> #>     4:     2      4         Tyrol    201   (25,45] female  domestic          AT #>     5:     2      4         Tyrol    202   (25,45]   male full time          AT #>    ---                                                                          #> 14823:  5997      4 Lower Austria 599704 (-Inf,16] female education          AT #> 14824:  5998      1 Upper Austria 599801   (25,45] female full time          AT #> 14825:  5999      1         Tyrol 599901   (25,45]   male full time          AT #> 14826:  6000      2         Tyrol 600001   (45,65]   male full time          AT #> 14827:  6000      2         Tyrol 600002   (45,65] female  disabled          AT #>          py010n py050n  py090n py100n py110n py120n py130n py140n hy040n #>           <num>  <num>   <num>  <num>  <num>  <num>  <num>  <num>  <num> #>     1:  9756.25      0    0.00      0      0      0      0      0 4273.9 #>     2: 12471.60      0    0.00      0      0      0      0      0 4273.9 #>     3:       NA     NA      NA     NA     NA     NA     NA     NA 4273.9 #>     4: 12487.03      0    0.00      0      0      0      0      0    0.0 #>     5: 42821.23      0    0.00      0      0      0      0      0    0.0 #>    ---                                                                   #> 14823:     0.00      0    0.00      0      0      0      0      0    0.0 #> 14824: 13962.56      0    0.00      0      0      0      0      0    0.0 #> 14825: 14685.18      0    0.00      0      0      0      0      0    0.0 #> 14826: 20606.82      0    0.00      0      0      0      0      0    0.0 #> 14827:     0.00      0 3825.63      0      0      0      0      0    0.0 #>         hy050n hy070n hy080n hy090n hy110n hy130n hy145n  eqSS eqIncome #>          <num>  <num>  <num>  <num>  <num>  <num>  <num> <num>    <num> #>     1: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     2: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     3: 2428.11      0      0  33.39      0      0      0   1.8 16090.69 #>     4: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>     5: 1549.72      0      0   2.13      0      0      0   2.1 27076.24 #>    ---                                                                  #> 14823: 1955.19      0      0   0.00      0      0      0   2.5 26508.20 #> 14824:    0.00      0      0 424.85      0      0      0   1.0 14387.41 #> 14825:    0.00      0      0 120.65      0      0      0   1.0 14805.83 #> 14826:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #> 14827:    0.00      0      0   0.00      0      0      0   1.5 16288.30 #>           db090  pWeight  year povertyRisk N.households      new_strata #>           <num>    <num> <num>      <lgcl>        <int>          <char> #>     1: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     2: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     3: 504.5696 504.5696  2010       FALSE          496         Tyrol_3 #>     4: 493.3824 493.3824  2010       FALSE          496         Tyrol_4 #>     5: 493.3824 493.3824  2010       FALSE          496         Tyrol_4 #>    ---                                                                  #> 14823: 556.4260 556.4260  2010       FALSE         1131 Lower Austria_4 #> 14824: 643.2557 643.2557  2010       FALSE         1068 Upper Austria_1 #> 14825: 679.7288 679.7288  2010       FALSE          496         Tyrol_1 #> 14826: 567.1544 567.1544  2010       FALSE          496         Tyrol_2 #> 14827: 567.1544 567.1544  2010       FALSE          496         Tyrol_2 #>        N.housholds #>              <int> #>     1:          79 #>     2:          79 #>     3:          79 #>     4:         102 #>     5:         102 #>    ---             #> 14823:         169 #> 14824:         262 #> 14825:         118 #> 14826:         149 #> 14827:         149 eusilc.bootstrap <- rescaled.bootstrap(eusilc,REP=10,strata=c(\"new_strata\"),                                        cluster=\"hid\",fpc=\"N.households\")"},{"path":"https://statistikat.github.io/surveysd/reference/summary.ipf.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Summary Output for IPF Calibration — summary.ipf","title":"Generate Summary Output for IPF Calibration — summary.ipf","text":"Generates detailed summary Iterative Proportional Fitting (IPF) calibration, providing complete tool evaluating calibration's success validity resulting weights. output list data.tables comprehensive evaluation, including: Calibration Results: calib_results_conP_* calib_results_conH_*: Key diagnostic tables compare calibrated margins population targets assess goodness fit via metrics like maxFac. Data Diagnostics: weighted data: excerpt final dataset calculated calibration weights. distribution weights: statistical overview weight distribution (min, max, CV). Detailed Margin Comparisons: conP_*, conH_*, *_adjusted, *_original, *_rel_diff_*: Tables compare original sample margins, calibrated margins, population targets, along relative differences.","code":""},{"path":"https://statistikat.github.io/surveysd/reference/summary.ipf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Summary Output for IPF Calibration — summary.ipf","text":"","code":"# S3 method for class 'ipf' summary(object, ...)"},{"path":"https://statistikat.github.io/surveysd/reference/summary.ipf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Summary Output for IPF Calibration — summary.ipf","text":"object object class ipf ... additional arguments","code":""},{"path":"https://statistikat.github.io/surveysd/reference/summary.ipf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Summary Output for IPF Calibration — summary.ipf","text":"list following outputs","code":""},{"path":"https://statistikat.github.io/surveysd/reference/summary.ipf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Summary Output for IPF Calibration — summary.ipf","text":"","code":"if (FALSE) { # \\dontrun{ # load data eusilc <- demo.eusilc(n = 1, prettyNames = TRUE)  # personal constraints conP1 <- xtabs(pWeight ~ age, data = eusilc) conP2 <- xtabs(pWeight ~ gender + region, data = eusilc) conP3 <- xtabs(pWeight*eqIncome ~ gender, data = eusilc)  # household constraints conH1 <- xtabs(pWeight ~ hsize + region, data = eusilc)  # simple usage ------------------------------------------  calibweights1 <- ipf(  eusilc,  conP = list(conP1, conP2, eqIncome = conP3),  bound = NULL,  verbose = TRUE ) output <- summary(calibweights1) # the output can easily be exported to an Excel file, e.g. with # library(openxlsx) # write.xlsx(output, \"SummaryIPF.xlsx\") } # }"},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-200","dir":"Changelog","previous_headings":"","what":"surveysd 2.0.0","title":"surveysd 2.0.0","text":"Fixed issue parameter period type haven::labelled calc.stError(). Refactored code make use new data.table variable env. Makes code readable stable. calc.stError() new parameter group.diff. group.diff=TRUE differences values defined group also calculated. instance produce difference poverty rate male female, addition estimates. Updated vignette accordingly. Fixed bug parameter adjust.var fun.adjust.var function calc.stError(). Changed parameter national relative.share calc.stError() included deprecate-message national = TRUE supplied. Fixed issue parameter looseH function ipf(). Fixed bug variables names created internal functions properly cleaned returning data.table output. Improved summary.ipf() included print.summary.ipf() order make output ipf() well convergence issues using ipf() intuitive. New parameter method draw.bootstrap() rescaled.bootstrap(). Can bei either \"Preston\" \"Rao-Wu\", see ?draw.bootstrap() new vignette. draw.bootstrap() can now used draw bootstrap replicates bootstrap replicates drawn previous year parameter already.selected. already.selected expects list data.tables indicating record already included bootstrap replicates previous period New function get.selection() create input parameter already.selected draw.bootstrap(). Updated included () unit tests.","code":"library(surveysd) set.seed(1234) eusilc <- demo.eusilc(n = 4,prettyNames = TRUE) dat_boot <- draw.bootstrap(eusilc, REP = 3, hid = \"hid\", weights = \"pWeight\",                            strata = \"region\", period = \"year\") dat_boot_calib <- recalib(dat_boot, conP.var = \"gender\", conH.var = \"region\")  # estimate weightedRatio for povertyRisk per period err.est <- calc.stError(dat_boot_calib, var = \"povertyRisk\",                         fun = weightedRatio, group = \"gender\",                         group.diff = TRUE)"},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-132","dir":"Changelog","previous_headings":"","what":"surveysd 1.3.2","title":"surveysd 1.3.2","text":"rescaled.bootstrap() additional parameter period identical one draw.bootstrap. period NULL boostraps drawn period strata/cluster $\\floor{\\frac{n}{2}}$ records drawn. produces consisten results make calibration afterwards easier. Improved numerical weighting computeLinearG1 use ipf(). computeLinearG1 now stable numerical variables used weighting. parameter numericalWeighting can passed recalib correctly passed along function ipf","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-13","dir":"Changelog","previous_headings":"","what":"surveysd 1.3","title":"surveysd 1.3","text":"new parameter minMaxTrim ipf() trim weights fix bug numericalWeighting reported “converged” converge fix bug checking cluster strata bootstrapping","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-12","dir":"Changelog","previous_headings":"","what":"surveysd 1.2","title":"surveysd 1.2","text":"Add vignette ipf() Resolve bug appeared constraints contained one household one person (#17)","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-111","dir":"Changelog","previous_headings":"","what":"surveysd 1.1.1","title":"surveysd 1.1.1","text":"recalib() accepts conP conH way ipf recalib() arguments epsP epsH, make convergence limits transparant fixed bug ipf() supplying hid=\"hid\", see https://github.com/statistikat/surveysd/pull/20. Thanks @asiripanich","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-110","dir":"Changelog","previous_headings":"","what":"surveysd 1.1.0","title":"surveysd 1.1.0","text":"use demo.eusilc() examples unit tests package remove simPop “Suggests” field (DESCRIPTION) remove hardcoded variable names default parameters allow calls recalib() without specifying conP.vars conH.vars","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-102","dir":"Changelog","previous_headings":"","what":"surveysd 1.0.2","title":"surveysd 1.0.2","text":"fix bug NSE update documentation calc.stError","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-101","dir":"Changelog","previous_headings":"","what":"surveysd 1.0.1","title":"surveysd 1.0.1","text":"fix bug fpc calculation (0824834) fix bug dummy data (5adb6b7) improve readability code resolve linters resolve issues datasets columns certain names (#7, #10) css updates automated linter-checking new badges (code coverage, cran) update setup vignettes fix issue household column factor (#12)","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-100","dir":"Changelog","previous_headings":"","what":"surveysd 1.0.0","title":"surveysd 1.0.0","text":"add bugfixes ported functions simplify tests update references methodology vignette fix sampling full population strata","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-023","dir":"Changelog","previous_headings":"","what":"surveysd 0.2.3","title":"surveysd 0.2.3","text":"Fix citation Resolve issue occured columns multiple classes","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-022","dir":"Changelog","previous_headings":"","what":"surveysd 0.2.2","title":"surveysd 0.2.2","text":"Update default parameters (#4, #5) Split README README + Get Started Bugfixes Update documentation titles, function categories vignette titles","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-021","dir":"Changelog","previous_headings":"","what":"surveysd 0.2.1","title":"surveysd 0.2.1","text":"Create vignette error estimation Bugfixes plotting ... argument calc.stError Documentation updates. Make example plots available gh-pages","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"surveysd-020","dir":"Changelog","previous_headings":"","what":"surveysd 0.2.0","title":"surveysd 0.2.0","text":"Automatically pass variable names household id, weights reference period draw.bootstrap downstream functions Reorganize names R source files","code":""},{"path":"https://statistikat.github.io/surveysd/news/index.html","id":"documentation-updates-0-2-0","dir":"Changelog","previous_headings":"","what":"Documentation updates","title":"surveysd 0.2.0","text":"Use markown pre-processing documentation Add github pages, badges logo export draw.bootstrap include prettyNames argument. update documenentation examples use new variable names Don’t load laeken data.table examples rewrite vignettes/TheoryWord.Rmd dynamic markdown file describing methodology package","code":""}]
