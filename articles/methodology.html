<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Methodology • surveysd</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Methodology">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">surveysd</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">2.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/surveysd.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/error_estimation.html">Error estimation</a></li>
    <li><a class="dropdown-item" href="../articles/ipf.html">Iterative Proportional Fitting</a></li>
    <li><a class="dropdown-item" href="../articles/methodology.html">Methodology</a></li>
    <li><a class="dropdown-item" href="../articles/raowu.html">Rao-Wu Bootstrap in surveysd</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/statistikat/surveysd/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Methodology</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/statistikat/surveysd/blob/master/vignettes/methodology.Rmd" class="external-link"><code>vignettes/methodology.Rmd</code></a></small>
      <div class="d-none name"><code>methodology.Rmd</code></div>
    </div>

    
    
<p>In the following we present the methodology in <code>surveysd</code>
by applying the workflow described in <code><a href="../articles/surveysd.html">vignette("surveysd")</a></code>
to multiple consecutive years of EU-SILC data for one country. The
methodology contains the following steps, in this order</p>
<ul>
<li>Draw
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap replicates from EU-SILC data for each year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t=1,\ldots,n_y</annotation></semantics></math>
separately. Since EU-SILC has a rotating panel design the bootstrap
replicate of a household is carried forward through the years. That is,
the bootstrap replicate of a household in the follow-up years is set
equal to the bootstrap replicate of the same household when it first
enters EU-SILC.</li>
<li>Multiply each set of bootstrap replicates by the sampling weights to
obtain uncalibrated bootstrap weights and calibrate each of the
uncalibrated bootstrap weights using iterative proportional
fitting.</li>
<li>Estimate the point estimate of interest
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
for each year and each calibrated bootstrap weight to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t=1,\ldots,n_y</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>.
For fixed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
apply a filter with equal weights for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msup><mi>y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y^*)}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo>*</mo></msup><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">y^*\in \{y_{t-1},y_{t},y_{t+1}\}</annotation></semantics></math>
, to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math>.
Estimate the variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
using the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math>.</li>
</ul>
<div class="section level2">
<h2 id="bootstrapping">Bootstrapping<a class="anchor" aria-label="anchor" href="#bootstrapping"></a>
</h2>
<p>Bootstrapping has long been around and used widely to estimate
confidence intervals and standard errors of point estimates.[<span class="citation">Efron (1979)</span>} Given a random sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X_1,\ldots,X_n)</annotation></semantics></math>
drawn from an unknown distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
the distribution of a point estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub><mo>;</mo><mi>F</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta(X_1,\ldots,X_n;F)</annotation></semantics></math>
can in many cases not be determined analytically. However when using
bootstrapping one can simulate the distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo stretchy="true" form="postfix">)</mo></mrow></msub><annotation encoding="application/x-tex">s_{(.)}</annotation></semantics></math>
be a bootstrap sample, e.g. drawing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
observations with replacement from the sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X_1,\ldots,X_n)</annotation></semantics></math>,
then one can estimate the standard deviation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
bootstrap samples through
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mover><mi>θ</mi><mo accent="true">¯</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></msqrt><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\theta(s_i)-\overline{\theta})^2} \quad, </annotation></semantics></math></p>
<p>with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>θ</mi><mo accent="true">¯</mo></mover><mo>:=</mo><mfrac><mn>1</mn><mi>B</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\overline{\theta}:=\frac{1}{B}\sum\limits_{i=1}^B\theta(s_i)</annotation></semantics></math>
as the sample mean over all bootstrap samples.</p>
<p>In context of sample surveys with sampling weights one can use
bootstrapping to calculate so called bootstrap weights. These are
computed via the bootstrap samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_{i}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>,
where for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_{i}</annotation></semantics></math>
every unit of the original sample can appear
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>-times.
With
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>f</mi><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">f_j^{i}</annotation></semantics></math>
as the frequency of occurrence of observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in bootstrap sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
the uncalibrated bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_{j}^{i}</annotation></semantics></math>
are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><mo>=</mo><msubsup><mi>f</mi><mi>j</mi><mi>i</mi></msubsup><msub><mi>w</mi><mi>j</mi></msub><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \tilde{b}_{j}^{i} = f_j^{i} w_j \quad,
</annotation></semantics></math></p>
<p>with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_j</annotation></semantics></math>
as the calibrated sampling weight of the original sample. Using
iterative proportional fitting procedures one can recalibrate the
bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>.</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_{j}^{.}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">j=1,\ldots,B</annotation></semantics></math>
to get the adapted or calibrated bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">b_j^i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">j=1,\ldots,B</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="rescaled-bootstrap">Rescaled Bootstrap<a class="anchor" aria-label="anchor" href="#rescaled-bootstrap"></a>
</h3>
<p>Since EU-SILC is a stratified sample without replacement drawn from a
finite population the naive bootstrap procedure, as described above,
does not take into account the heterogeneous inclusion probabilities of
each sample unit. Thus it will not yield satisfactory results. Therefore
we will use the so called rescaled bootstrap procedure introduced and
investigated by <span class="citation">(Rao and Wu 1988)</span>. The
bootstrap samples are selected without replacement and do incorporate
the stratification as well as clustering on multiple stages (see <span class="citation">(Chipperfield and Preston 2007)</span>,<span class="citation">(Preston 2009)</span>).</p>
<p>For simplistic reasons we will only describe the rescaled bootstrap
procedure for a two stage stratified sampling design. For more details
on a general formulation please see <span class="citation">(Preston
2009)</span>.</p>
</div>
<div class="section level3">
<h3 id="sampling-design">Sampling design<a class="anchor" aria-label="anchor" href="#sampling-design"></a>
</h3>
<p>Consider the finite population
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
which is divided into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
non-overlapping strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>⋃</mo><mrow><mi>h</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>H</mi></mrow></munder><msub><mi>U</mi><mi>h</mi></msub><mo>=</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\bigcup\limits_{h=1,\ldots,H} U_h = U</annotation></semantics></math>,
of which each strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
contains of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>h</mi></msub><annotation encoding="application/x-tex">N_h</annotation></semantics></math>
clusters. For each strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">C_{hc}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">c=1,\ldots,n_h</annotation></semantics></math>
clusters are drawn, containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">N_{hc}</annotation></semantics></math>
households. Furthermore in each cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">C_{hc}</annotation></semantics></math>
of each strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
simple random sampling is performed to select a set of households
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">j=1,\ldots,n_{hc}</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="bootstrap-procedure">Bootstrap procedure<a class="anchor" aria-label="anchor" href="#bootstrap-procedure"></a>
</h3>
<p>In contrast to the naive bootstrap procedure where for a stage,
containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
sampling units, the bootstrap replicate is obtained by drawing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
sampling units with replacement, for the rescaled bootstrap procedure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mo>*</mo></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">n^*=\left\lfloor\frac{n}{2}\right\rfloor</annotation></semantics></math>
sampling units are drawn without replacement. Given a value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>x</mi><mo stretchy="false" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor x\rfloor</annotation></semantics></math>
denotes the largest integer smaller than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>,
whereas
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌈</mo><mi>x</mi><mo stretchy="false" form="postfix">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil x\rceil</annotation></semantics></math>
denotes the smallest integer lager then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.
<span class="citation">(Chipperfield and Preston 2007)</span> have shown
that the choice of either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{n}{2}\right\rfloor</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">⌈</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌉</mo></mrow><annotation encoding="application/x-tex">\left\lceil\frac{n}{2}\right\rceil</annotation></semantics></math>
is optimal for bootstrap samples without replacement, although
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{n}{2}\right\rfloor</annotation></semantics></math>
has the desirable property that the resulting uncalibrated bootstrap
weights will never be negative.</p>
<p>At the first stage the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
bootstrap replicate,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msubsup><annotation encoding="application/x-tex">f^{i,1}_{hc}</annotation></semantics></math>,
for each cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">C_{hc}</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">c=1,\ldots,n_h</annotation></semantics></math>,
belonging to strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>,
is defined by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>λ</mi><mi>h</mi></msub><mo>+</mo><msub><mi>λ</mi><mi>h</mi></msub><mfrac><msub><mi>n</mi><mi>h</mi></msub><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup></mfrac><msub><mi>δ</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>h</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">
  f^{i,1}_{hc} = 1-\lambda_h+\lambda_h\frac{n_h}{n_h^*}\delta_{hc} \quad\quad \forall c \in \{1,\ldots,n_h\} 
</annotation></semantics></math> with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac><msub><mi>n</mi><mi>h</mi></msub><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">
  n_h^* = \left\lfloor\frac{n_h}{2}\right\rfloor
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>h</mi></msub><mo>=</mo><msqrt><mfrac><mrow><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><msub><mi>n</mi><mi>h</mi></msub><msub><mi>N</mi><mi>h</mi></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup></mrow></mfrac></msqrt><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \lambda_h = \sqrt{\frac{n_h^*(1-\frac{n_h}{N_h})}{n_h-n_h^*}} \quad ,
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\delta_{hc}=1</annotation></semantics></math>
if cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is selected in the sub-sample of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup><annotation encoding="application/x-tex">n_h^*</annotation></semantics></math>
and 0 otherwise.</p>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
bootstrap replicate at the second stage,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msubsup><annotation encoding="application/x-tex">f^{i,2}_{hcj}</annotation></semantics></math>,
for each household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">j=1,\ldots,n_{hc}</annotation></semantics></math>,
belonging to cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
in strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
is defined by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msubsup><mo>=</mo><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msubsup><mo>−</mo><msub><mi>λ</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><msqrt><mfrac><msub><mi>n</mi><mi>h</mi></msub><msubsup><mi>n</mi><mi>h</mi><mo>*</mo></msubsup></mfrac></msqrt><msub><mi>δ</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><msubsup><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow><mo>*</mo></msubsup></mfrac><msub><mi>δ</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>h</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">
  f^{i,2}_{hcj} = f^{i,1}_{hc} - \lambda_{hc}\sqrt{\frac{n_h}{n_h^*}}\delta_{hc}\left[\frac{n_{hc}}{n_{hc}^*}\delta_{hcj}-1\right] \quad\quad \forall c \in \{1,\ldots,n_h\}
</annotation></semantics></math> with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow><mo>*</mo></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">⌊</mo><mfrac><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="true" form="postfix">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">
  n_{hc}^* = \left\lfloor\frac{n_{hc}}{2}\right\rfloor 
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mo>=</mo><msqrt><mfrac><mrow><msubsup><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow><mo>*</mo></msubsup><msub><mi>N</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><msub><mi>N</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow></msub><mo>−</mo><msubsup><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow><mo>*</mo></msubsup></mrow></mfrac></msqrt><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \lambda_{hc} = \sqrt{\frac{n_{hc}^*N_h(1-\frac{n_{hc}}{N_{hc}})}{n_{hc}-n_{hc}^*}} \quad ,
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\delta_{hcj}=1</annotation></semantics></math>
if household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is selected in the sub sample of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>n</mi><mrow><mi>h</mi><mi>c</mi></mrow><mo>*</mo></msubsup><annotation encoding="application/x-tex">n_{hc}^*</annotation></semantics></math>
and 0 otherwise.</p>
</div>
<div class="section level3">
<h3 id="single-psus">Single PSUs<a class="anchor" aria-label="anchor" href="#single-psus"></a>
</h3>
<p>When dealing with multistage sampling designs the issue of single
PSUs, e.g. a single response unit is present at a stage or in a strata,
can occur. When applying bootstrapping procedures these single PSUs can
lead to a variety of issues. For the methodology proposed in this work
we combined single PSUs at each stage with the next smallest strata or
cluster, before applying the bootstrap procedure.</p>
</div>
<div class="section level3">
<h3 id="taking-bootstrap-replicates-forward">Taking bootstrap replicates forward<a class="anchor" aria-label="anchor" href="#taking-bootstrap-replicates-forward"></a>
</h3>
<p>The bootstrap procedure above is applied on the EU-SILC data for each
year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t=1,\ldots,n_y</annotation></semantics></math>
separately. Since EU-SILC is a yearly survey with rotating penal design
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
bootstrap replicate at the second stage,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msubsup><annotation encoding="application/x-tex">f^{i,2}_{hcj}</annotation></semantics></math>,
for a household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>
is taken forward until the household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>
drops out of the sample. That is, for the household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>,
which enters EU-SILC at year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>
and drops out at year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mover><mi>t</mi><mo accent="true">̃</mo></mover></msub><annotation encoding="application/x-tex">y_{\tilde{t}}</annotation></semantics></math>,
the bootstrap replicates for the years
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mover><mi>t</mi><mo accent="true">̃</mo></mover></msub></mrow><annotation encoding="application/x-tex">y_2,\ldots,y_{\tilde{t}}</annotation></semantics></math>
are set to the bootstrap replicate of the year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="split-households">Split households<a class="anchor" aria-label="anchor" href="#split-households"></a>
</h3>
<p>Due to the rotating penal design so called split households can
occur. For a household participating in the EU-SILC survey it is
possible that one or more residents move to a new so called split
household, which is followed up on in the next wave. To take this
dynamic into account we extended the procedure of taking forward the
bootstrap replicate of a household for consecutive waves of EU-SILC by
taking forward the bootstrap replicate to the split household. That
means, that also any new individuals in the split household will inherit
this bootstrap replicate.</p>
<p>Taking bootstrap replicates forward as well as considering split
households ensures that bootstrap replicates are more comparable in
structure with the actual design of EU-SILC.</p>
</div>
<div class="section level3">
<h3 id="uncalibrated-bootstrap-weights">Uncalibrated bootstrap weights<a class="anchor" aria-label="anchor" href="#uncalibrated-bootstrap-weights"></a>
</h3>
<p>Using the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
bootstrap replicates at the second stage one can calculate the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
uncalibrated bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mi>i</mi></msubsup><annotation encoding="application/x-tex">b_{hcj}^{i}</annotation></semantics></math>
for each household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>
in cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
contained in strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mi>i</mi></msubsup><mo>=</mo><msubsup><mi>f</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msubsup><msub><mi>w</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \tilde{b}_{hcj}^{i} = f^{i,2}_{hcj} w_{hcj} \quad,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">w_{hcj}</annotation></semantics></math>
corresponds to the original household weight contained in the
sample.</p>
<p>For ease of readability we will drop the subindices regarding strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
and cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
for the following sections, meaning that the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
household in cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
contained in strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>h</mi><mi>c</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">Y_{hcj}</annotation></semantics></math>,
will now be denoted as the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
household,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>j</mi></msub><annotation encoding="application/x-tex">Y_{j}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is the position of the household in the data. In accordance to this the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
uncalibrated bootstrap replicates for household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
are thus denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{i}</annotation></semantics></math>
and the original household weight as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_j</annotation></semantics></math>.</p>
</div>
</div>
<div class="section level2">
<h2 id="iterative-proportional-fitting-ipf">Iterative proportional fitting (IPF)<a class="anchor" aria-label="anchor" href="#iterative-proportional-fitting-ipf"></a>
</h2>
<p>The uncalibrated bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{i}</annotation></semantics></math>
computed through the rescaled bootstrap procedure yields population
statistics that differ from the known population margins of specified
sociodemographic variables for which the base weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_j</annotation></semantics></math>
have been calibrated. To adjust for this the bootstrap weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_{j}^{i}</annotation></semantics></math>
can be recalibrated using iterative proportional fitting as described in
<span class="citation">(Meraner, Gumprecht, and Kowarik
2016)</span>.</p>
<p>Let the original weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>j</mi></msub><annotation encoding="application/x-tex">w_{j}</annotation></semantics></math>
be calibrated for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mi>P</mi></msub><mo>+</mo><msub><mi>n</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">n=n_P+n_H</annotation></semantics></math>
sociodemographic variables which are divided into the sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒫</mi><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>p</mi><mi>c</mi></msub><mo>,</mo><mi>c</mi><mo>=</mo><mn>1</mn><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>P</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}:=\{p_{c}, c=1 \ldots,n_P\}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℋ</mi><mo>:=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>h</mi><mi>c</mi></msub><mo>,</mo><mi>c</mi><mo>=</mo><mn>1</mn><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>H</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{H}:=\{h_{c}, c=1 \ldots,n_H\}</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒫</mi><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math>
correspond to personal, for example gender or age, or household
variables, like region or households size, respectively. Each variable
in either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒫</mi><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math>
can take on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mi>c</mi></msub><annotation encoding="application/x-tex">P_{c}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mi>c</mi></msub><annotation encoding="application/x-tex">H_{c}</annotation></semantics></math>
values with and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><annotation encoding="application/x-tex">N^{p_c}_v</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>P</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">v=1,\ldots,P_c</annotation></semantics></math>,
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><annotation encoding="application/x-tex">N^{h_c}_v</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>H</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">v=1,\ldots,H_c</annotation></semantics></math>,
as the corresponding population margins. Starting with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k=0</annotation></semantics></math>
the iterative proportional fitting procedure is applied on each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{i}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots, B</annotation></semantics></math>
separately. The weights are first updated for personal and afterwards
updated for household variables. If constraints regarding the
populations margins are not met
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is raised by 1 and the procedure starts from the beginning. For the
following denote as starting weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>:=</mo><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">\tilde{b}_j^{[0]}:=\tilde{b}_j^{i}</annotation></semantics></math>
for fixed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="adjustment-and-trimming-for-mathcalp">Adjustment and trimming for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒫</mi><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#adjustment-and-trimming-for-mathcalp"></a>
</h3>
<p>The uncalibrated bootstrap weight
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{[(n+1)k+c-1]}</annotation></semantics></math>
for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
observation is iteratively multiplied by a factor so that the projected
distribution of the population matches the respective calibration
specification
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><msub><mi>p</mi><mi>c</mi></msub></msub><annotation encoding="application/x-tex">N_{p_c}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">c=1, \ldots,n_P</annotation></semantics></math>.
For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>P</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">c \in \left\{1, \ldots,n_P\right\}</annotation></semantics></math>
the calibrated weights against
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><annotation encoding="application/x-tex">N^{p_c}_v</annotation></semantics></math>
are computed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>=</mo><msup><msub><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msup><mfrac><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \tilde{b}_j^{[(n+1)k+c]} = {\tilde{b}_j}^{[(n+1)k+c-1]}\frac{N^{p_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+c-1]}},
</annotation></semantics></math> where the summation in the denominator
expands over all observations which have the same value as observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
for the sociodemographic variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>c</mi></msub><annotation encoding="application/x-tex">p_c</annotation></semantics></math>.
If any weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mi>k</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{[nk+c]}</annotation></semantics></math>
fall outside the range
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><msub><mi>w</mi><mi>j</mi></msub><mn>4</mn></mfrac><mo>;</mo><mn>4</mn><msub><mi>w</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\left[\frac{w_j}{4};4w_j\right]</annotation></semantics></math>
they will be recoded to the nearest of the two boundaries. The choice of
the boundaries results from expert-based opinions and restricts the
variance of which has a positive effect on the sampling error. This
procedure represents a common form of weight trimming where very large
or small weights are trimmed in order to reduce variance in exchange for
a possible increase in bias (<span class="citation">(Potter
1990)</span>,<span class="citation">(Potter 1993)</span>).</p>
</div>
<div class="section level3">
<h3 id="averaging-weights-within-households">Averaging weights within households<a class="anchor" aria-label="anchor" href="#averaging-weights-within-households"></a>
</h3>
<p>Since the sociodemographic variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>p</mi><msub><mi>n</mi><mi>c</mi></msub></msub></mrow><annotation encoding="application/x-tex">p_1,\ldots,p_{n_c}</annotation></semantics></math>
include person-specific variables, the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">\tilde{b}_j^{[nk+n_p]}</annotation></semantics></math>
resulting from the iterative multiplication can be unequal for members
of the same household. This can lead to inconsistencies between results
projected with household and person weights. To avoid such
inconsistencies each household member is assigned the mean of the
household weights. That is for each person
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>a</mi></msub><annotation encoding="application/x-tex">h_a</annotation></semantics></math>
household members, the weights are defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mrow><mi>l</mi><mo>∈</mo><mi>a</mi></mrow></munder><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow><msub><mi>h</mi><mi>a</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">
  \tilde{b}_j^{[(n+1)k+n_p+1]} = \frac{{\sum\limits_{l\in a}} {\tilde{b}_l^{[(n+1)k+n_p]}}}{h_a}
</annotation></semantics></math> This can result in losing the
population structure performed in the previous subsection.</p>
</div>
<div class="section level3">
<h3 id="adjustment-and-trimming-for-mathcalh">Adjustment and trimming for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#adjustment-and-trimming-for-mathcalh"></a>
</h3>
<p>After adjustment for individual variables the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">b_j^{[nk+n_p+1]}</annotation></semantics></math>
are updated for the set of household variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math>
according to a household convergence constraint parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>h</mi></msub><annotation encoding="application/x-tex">\epsilon_h</annotation></semantics></math>.
The parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>h</mi></msub><annotation encoding="application/x-tex">\epsilon_h</annotation></semantics></math>
represent the allowed deviation from the population margins using the
weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">b_j^{[nk+n_p+1]}</annotation></semantics></math>
compared to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><annotation encoding="application/x-tex">N^{h_c}_v</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">c=1,\ldots,n_H</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>H</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">v=1,\ldots,H_c</annotation></semantics></math>.
The updated weights are computed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mfrac><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mi>b</mi><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow></mfrac><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mo>∉</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mn>0.9</mn><msub><mi>ϵ</mi><mi>h</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mn>0.9</mn><msub><mi>ϵ</mi><mi>h</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><mspace width="1.0em"></mspace><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  b_j^{[(n+1)k+n_p+c+1]} =
  \begin{cases}
    b_j^{[(n+1)k+n_p+1]}\frac{N^{h_c}_v}{\sum\limits_{l} b_l^{[(n+1)k+n_p+1]}} \quad \text{if } \sum\limits_{l} b_j^{[(n+1)k+n_p+1]} \notin ((1-0.9\epsilon_h)N^{h_c}_v,(1+0.9\epsilon_h)N^{h_c}_v) \\
    b_j^{[(n+1)k+n_p+1]} \quad \text{otherwise}
  \end{cases}
</annotation></semantics></math> with the summation in the denominator
ranging over all households
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>
which take on the same values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>c</mi></msub><annotation encoding="application/x-tex">h_c</annotation></semantics></math>
as observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
As described in the previous subsection the new weight are recoded if
they exceed the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mfrac><msub><mi>w</mi><mi>j</mi></msub><mn>4</mn></mfrac><mo>;</mo><mn>4</mn><msub><mi>w</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\frac{w_j}{4};4w_j]</annotation></semantics></math>
and set to the upper or lower bound, depending of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msubsup><annotation encoding="application/x-tex">b_j^{[(n+1)k+n_p+c+1]}</annotation></semantics></math>
falls below or above the interval respectively.</p>
</div>
<div class="section level3">
<h3 id="convergence">Convergence<a class="anchor" aria-label="anchor" href="#convergence"></a>
</h3>
<p>For each adjustment and trimming step the factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msubsup><mi>N</mi><mi>v</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mi>b</mi><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow></mfrac><annotation encoding="application/x-tex">\frac{N^{(.)}_v}{\sum\limits_{l} b_l^{[(n+1)k+j]}}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo>∖</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>n</mi><mi>p</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">j\in \{1,\ldots,n+1\}\backslash \{n_p+1\}</annotation></semantics></math>,
is checked against convergence constraints for households,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>h</mi></msub><annotation encoding="application/x-tex">\epsilon_h</annotation></semantics></math>,
or personal variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\epsilon_p</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(.)</annotation></semantics></math>
corresponds to either a household or personal variable. To be more
precise for variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒫</mi><annotation encoding="application/x-tex">\mathcal{P}</annotation></semantics></math>
the constraints</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow></mfrac><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>ϵ</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><msub><mi>ϵ</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>p</mi><mi>c</mi></msub></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac{N^{p_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+j]}} \in ((1-\epsilon_p)N^{p_c}_v,(1+\epsilon_p)N^{p_c}_v)
</annotation></semantics></math> and for variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℋ</mi><annotation encoding="application/x-tex">\mathcal{H}</annotation></semantics></math>
the constraints</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mrow><munder><mo>∑</mo><mi>l</mi></munder><msubsup><mover><mi>b</mi><mo accent="true">̃</mo></mover><mi>l</mi><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow></msubsup></mrow></mfrac><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>ϵ</mi><mi>h</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><msub><mi>ϵ</mi><mi>h</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>N</mi><mi>v</mi><msub><mi>h</mi><mi>c</mi></msub></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac{N^{h_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+j]}} \in ((1-\epsilon_h)N^{h_c}_v,(1+\epsilon_h)N^{h_c}_v)
</annotation></semantics></math> are verified, where the sum in the
denominator expands over all observations which have the same value for
variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>c</mi></msub><annotation encoding="application/x-tex">h_c</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>c</mi></msub><annotation encoding="application/x-tex">p_c</annotation></semantics></math>.
If these constraints hold true the algorithm reaches convergence,
otherwise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is raised by 1 and the procedure repeats itself.</p>
<p>The above described calibration procedure is applied on each year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
of EU-SILC separately,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><msub><mi>n</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t=1,\ldots n_y</annotation></semantics></math>,
thus resulting in so called calibrated bootstrap sample weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">b_{j}^{(i,{y_t})}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>
for each year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
and each household
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.</p>
</div>
</div>
<div class="section level2">
<h2 id="variance-estimation">Variance estimation<a class="anchor" aria-label="anchor" href="#variance-estimation"></a>
</h2>
<p>Applying the previously described algorithms to EU-SILC data for
multiple consecutive years
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><msub><mi>n</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t=1,\ldots n_y</annotation></semantics></math>,
yields calibrated bootstrap sample weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">b_{j}^{(i,{y_t})}</annotation></semantics></math>
for each year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>.
Using the calibrated bootstrap sample weights it is straight forward to
compute the standard error of a point estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mtext mathvariant="bold">𝐗</mtext><msub><mi>y</mi><mi>t</mi></msub></msup><mo>,</mo><msup><mtext mathvariant="bold">𝐰</mtext><msub><mi>y</mi><mi>t</mi></msub></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta(\textbf{X}^{y_t},\textbf{w}^{y_t})</annotation></semantics></math>
for year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">𝐗</mtext><msub><mi>y</mi><mi>t</mi></msub></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>X</mi><mn>1</mn><msub><mi>y</mi><mi>t</mi></msub></msubsup><mo>,</mo><mi>…</mi><mo>,</mo><msubsup><mi>X</mi><mi>n</mi><msub><mi>y</mi><mi>t</mi></msub></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\textbf{X}^{y_t}=(X_1^{y_t},\ldots,X_n^{y_t})</annotation></semantics></math>
as the vector of observations for the variable of interest in the survey
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">𝐰</mtext><msub><mi>y</mi><mi>t</mi></msub></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>1</mn><msub><mi>y</mi><mi>t</mi></msub></msubsup><mo>,</mo><mi>…</mi><mo>,</mo><msubsup><mi>w</mi><mi>n</mi><msub><mi>y</mi><mi>t</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\textbf{w}^{y_t}=(w_1^{y_t},\ldots,w_n^{y_t}</annotation></semantics></math>
as the corresponding weight vector, with</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>−</mo><mover><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo accent="true">¯</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
  sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\theta^{(i,y_t)}-\overline{\theta^{(.,y_t)}})^2} 
</annotation></semantics></math> with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo accent="true">¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>B</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mspace width="1.0em"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \overline{\theta^{(.,y_t)}} = \frac{1}{B}\sum\limits_{i=1}^B\theta^{(i,y_t)} \quad,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>:=</mo><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mtext mathvariant="bold">𝐗</mtext><msub><mi>y</mi><mi>t</mi></msub></msup><mo>,</mo><msup><mtext mathvariant="bold">𝐛</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta^{(i,y_t)}:=\theta(\textbf{X}^{y_t},\textbf{b}^{(i,{y_t})})</annotation></semantics></math>
is the estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
in the year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
using the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th
vector of calibrated bootstrap weights.</p>
<p>As already mentioned the standard error estimation for indicators in
EU-SILC yields high quality results for NUTS1 or country level. When
estimation indicators on regional or other sub-aggregate levels one is
confronted with point estimates yielding high variance.</p>
<p>To overcome this issue we propose to estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
for 3, consecutive years using the calibrated bootstrap weights, thus
calculating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>.
For fixed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
one can apply a filter with equal filter weights on the time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}</annotation></semantics></math>
to create
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>=</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>+</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>+</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">]</mo></mrow><mspace width="1.0em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \tilde{\theta}^{(i,y_t)} = \frac{1}{3}\left[\theta^{(i,y_{t-1})}+\theta^{(i,y_t)}+\theta^{(i,y_{t+1})}\right] \quad .
</annotation></semantics></math></p>
<p>Doing this for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>,
yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,B</annotation></semantics></math>.
The standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
can then be estimated with</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>−</mo><mover><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo accent="true">¯</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
  sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\tilde{\theta}^{(i,y_t)}-\overline{\tilde{\theta}^{(.,y_t)}})^2}
</annotation></semantics></math> with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo accent="true">¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>B</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></munderover><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mspace width="1.0em"></mspace><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \overline{\tilde{\theta}^{(.,y_t)}}=\frac{1}{B}\sum\limits_{i=1}^B\tilde{\theta}^{(i,y_t)} \quad.
</annotation></semantics></math></p>
<p>Applying the filter over the time series of estimated
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\theta^{(i,y_t)}</annotation></semantics></math>
leads to a reduction of variance for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
since the filter reduces the noise in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}</annotation></semantics></math>
and thus leading to a more narrow distribution for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\tilde{\theta}^{(i,y_t)}</annotation></semantics></math>.</p>
<p>It should also be noted that estimating indicators from a survey with
rotating panel design is in general not straight forward because of the
high correlation between consecutive years. However with our approach to
use bootstrap weights, which are independent from each other, we can
bypass the cumbersome calculation of various correlations, and apply
them directly to estimate the standard error. <span class="citation">(Bauer et al. 2013)</span> showed that using the
proposed method on EU-SILC data for Austria the reduction in resulting
standard errors corresponds in a theoretical increase in sample size by
about
25<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>%</mi><annotation encoding="application/x-tex">\%</annotation></semantics></math>.
Furthermore this study compared this method to the use of small area
estimation techniques and on average the use of bootstrap sample weights
yielded more stable results.</p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-silcstudy" class="csl-entry">
Bauer, Martin, Matthias Till, Richard Heuberger, Marcel Bilgili, Thomas
Glaser, Elisabeth Kafka, Johannes Klotz, et al. 2013. <span>“Studie Zu
Armut Und Sozialer Eingliederung in Den
Bundesl<span>"a</span>ndern.”</span> Statistik Austria [in German].
</div>
<div id="ref-chipprest2007" class="csl-entry">
Chipperfield, James, and John Preston. 2007. <span>“Efficient Bootstrap
for Business Surveys.”</span> <em>Survey Methodology</em> 33 (December):
167–72. <a href="https://www150.statcan.gc.ca/n1/en/catalogue/12-001-X200700210494" class="external-link">https://www150.statcan.gc.ca/n1/en/catalogue/12-001-X200700210494</a>.
</div>
<div id="ref-efron1979" class="csl-entry">
Efron, B. 1979. <span>“Bootstrap Methods: Another Look at the
Jackknife.”</span> <em>Ann. Statist.</em> 7 (1): 1–26. <a href="https://doi.org/10.1214/aos/1176344552" class="external-link">https://doi.org/10.1214/aos/1176344552</a>.
</div>
<div id="ref-mekogu2016" class="csl-entry">
Meraner, Angelika, Daniela Gumprecht, and Alexander Kowarik. 2016.
<span>“Weighting Procedure of the Austrian Microcensus Using
Administrative Data.”</span> <em>Austrian Journal of Statistics</em> 45
(June): 3. <a href="https://doi.org/10.17713/ajs.v45i3.120" class="external-link">https://doi.org/10.17713/ajs.v45i3.120</a>.
</div>
<div id="ref-potter90" class="csl-entry">
Potter, Frank J. 1990. <span>“A Study of Procedures to Identify and Trim
Extreme Sampling Weights.”</span> <em>Proceedings of the American
Statistical Association, Section on Survey Research Methods</em>,
225–30. <a href="http://www.asasrms.org/Proceedings/papers/1990_034.pdf" class="external-link">http://www.asasrms.org/Proceedings/papers/1990_034.pdf</a>.
</div>
<div id="ref-potter93" class="csl-entry">
———. 1993. <span>“The Effect of Weight Trimming on Nonlinear Survey
Estimates.”</span> <em>Proceedings of the American Statistical
Association, Section on Survey Research Methods</em> 2: 758–63. <a href="http://www.asasrms.org/Proceedings/papers/1993_127.pdf" class="external-link">http://www.asasrms.org/Proceedings/papers/1993_127.pdf</a>.
</div>
<div id="ref-prest2009" class="csl-entry">
Preston, J. 2009. <span>“Rescaled Bootstrap for Stratified Multistage
Sampling.”</span> <em>Survey Methodology</em> 35 (December): 227–34. <a href="https://www150.statcan.gc.ca/n1/en/catalogue/12-001-X200900211044" class="external-link">https://www150.statcan.gc.ca/n1/en/catalogue/12-001-X200900211044</a>.
</div>
<div id="ref-raowu1988" class="csl-entry">
Rao, J. N. K., and C. F. J. Wu. 1988. <span>“Resampling Inference with
Complex Survey Data.”</span> <em>Journal of the American Statistical
Association</em> 83 (401): 231–41.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Johannes Gussenbauer, Alexander Kowarik, Eileen Vattheuer, Gregor de Cillia.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
